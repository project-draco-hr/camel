{
  if (hasNamedParameters(query)) {
    try {
      final Map<?,?> bodyMap=exchange.getContext().getTypeConverter().tryConvertTo(Map.class,value);
      final Map<?,?> headerMap=exchange.getIn().hasHeaders() ? exchange.getIn().getHeaders() : null;
      return new Iterator<Object>(){
        private NamedQueryParser parser=new NamedQueryParser(query);
        private Object next;
        private boolean done;
        @Override public boolean hasNext(){
          if (done) {
            return false;
          }
          if (next == null) {
            next=next();
          }
          return next != null;
        }
        @Override public Object next(){
          if (next == null) {
            String key=parser.next();
            if (key == null) {
              done=true;
              return null;
            }
            boolean contains=bodyMap != null ? bodyMap.containsKey(key) : false;
            contains|=headerMap != null ? headerMap.containsKey(key) : false;
            if (!contains) {
              throw new RuntimeExchangeException("Cannot find key [" + key + "] in message body or headers to use when setting named parameter in query ["+ query+ "]",exchange);
            }
            next=bodyMap != null ? bodyMap.get(key) : null;
            if (next == null) {
              next=headerMap != null ? headerMap.get(key) : null;
            }
          }
          Object answer=next;
          next=null;
          return answer;
        }
        @Override public void remove(){
        }
      }
;
    }
 catch (    Exception e) {
      throw new SQLException("The message body must be a java.util.Map type when using named parameters in the query: " + query,e);
    }
  }
 else {
    if (value instanceof String) {
      String[] tokens=StringQuoteHelper.splitSafeQuote((String)value,separator,true);
      List<String> list=Arrays.asList(tokens);
      return list.iterator();
    }
 else {
      return exchange.getContext().getTypeConverter().convertTo(Iterator.class,value);
    }
  }
}
