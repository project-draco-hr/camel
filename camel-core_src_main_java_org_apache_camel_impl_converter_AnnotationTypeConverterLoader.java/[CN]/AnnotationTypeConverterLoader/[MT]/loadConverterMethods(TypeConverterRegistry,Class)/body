{
  if (visitedClasses.contains(type)) {
    return;
  }
  visitedClasses.add(type);
  try {
    Method[] methods=type.getDeclaredMethods();
    CachingInjector injector=null;
    for (    Method method : methods) {
      boolean found=method.getAnnotation(Converter.class) != null;
      if (!found) {
        Annotation[] annotations=method.getAnnotations();
        for (        Annotation a : annotations) {
          Annotation[] metaAnnotations=a.annotationType().getAnnotations();
          for (          Annotation meta : metaAnnotations) {
            if (meta.annotationType().getName().equals(Converter.class.getName())) {
              found=true;
              break;
            }
          }
          if (found) {
            break;
          }
        }
      }
      if (found) {
        if (isValidConverterMethod(method)) {
          int modifiers=method.getModifiers();
          if (isAbstract(modifiers) || !isPublic(modifiers)) {
            LOG.warn("Ignoring bad converter on type: " + type.getName() + " method: "+ method+ " as a converter method is not a public and concrete method");
          }
 else {
            Class<?> toType=method.getReturnType();
            if (toType.equals(Void.class)) {
              LOG.warn("Ignoring bad converter on type: " + type.getName() + " method: "+ method+ " as a converter method returns a void method");
            }
 else {
              Class<?> fromType=method.getParameterTypes()[0];
              if (isStatic(modifiers)) {
                registerTypeConverter(registry,method,toType,fromType,new StaticMethodTypeConverter(method));
              }
 else {
                if (injector == null) {
                  injector=new CachingInjector(registry,type);
                }
                registerTypeConverter(registry,method,toType,fromType,new InstanceMethodTypeConverter(injector,method));
              }
            }
          }
        }
 else {
          LOG.warn("Ignoring bad converter on type: " + type.getName() + " method: "+ method+ " as a converter method should have one parameter");
        }
      }
    }
    Class superclass=type.getSuperclass();
    if (superclass != null && !superclass.equals(Object.class)) {
      loadConverterMethods(registry,superclass);
    }
  }
 catch (  NoClassDefFoundError e) {
    LOG.warn("Ignoring converter type: " + type.getName() + " as a dependent class could not be found: "+ e,e);
  }
}
