{
  if (isValidFallbackConverterMethod(method)) {
    int modifiers=method.getModifiers();
    if (isAbstract(modifiers) || !isPublic(modifiers)) {
      LOG.warn("Ignoring bad fallback converter on type: " + type.getCanonicalName() + " method: "+ method+ " as a fallback converter method is not a public and concrete method");
    }
 else {
      Class<?> toType=method.getReturnType();
      if (toType.equals(Void.class)) {
        LOG.warn("Ignoring bad fallback converter on type: " + type.getCanonicalName() + " method: "+ method+ " as a fallback converter method returns a void method");
      }
 else {
        if (isStatic(modifiers)) {
          registerFallbackTypeConverter(registry,new StaticMethodFallbackTypeConverter(method,registry));
        }
 else {
          if (injector == null) {
            injector=new CachingInjector(registry,type);
          }
          registerFallbackTypeConverter(registry,new InstanceMethodFallbackTypeConverter(injector,method,registry));
        }
      }
    }
  }
 else {
    LOG.warn("Ignoring bad fallback converter on type: " + type.getCanonicalName() + " method: "+ method+ " as a fallback converter method should have one parameter");
  }
  return injector;
}
