{
  DefaultMessageListenerContainer answer=new DefaultMessageListenerContainer();
  answer.setDestinationName("temporary");
  answer.setDestinationResolver(new DestinationResolver(){
    public Destination resolveDestinationName(    Session session,    String destinationName,    boolean pubSubDomain) throws JMSException {
      TemporaryQueue queue=session.createTemporaryQueue();
      setReplyTo(queue);
      return queue;
    }
  }
);
  answer.setAutoStartup(true);
  if (endpoint.getMaxMessagesPerTask() >= 0) {
    answer.setMaxMessagesPerTask(endpoint.getMaxMessagesPerTask());
  }
  answer.setMessageListener(this);
  answer.setPubSubDomain(false);
  answer.setSubscriptionDurable(false);
  answer.setConcurrentConsumers(endpoint.getConcurrentConsumers());
  if (endpoint.getMaxConcurrentConsumers() > 0) {
    answer.setMaxConcurrentConsumers(endpoint.getMaxConcurrentConsumers());
  }
  answer.setConnectionFactory(endpoint.getConnectionFactory());
  String clientId=endpoint.getClientId();
  if (clientId != null) {
    clientId+=".CamelReplyManager";
    answer.setClientId(clientId);
  }
  answer.setSessionTransacted(false);
  if (endpoint.getExceptionListener() != null) {
    answer.setExceptionListener(endpoint.getExceptionListener());
  }
  if (endpoint.getErrorHandler() != null) {
    answer.setErrorHandler(endpoint.getErrorHandler());
  }
 else {
    answer.setErrorHandler(new DefaultSpringErrorHandler(TemporaryQueueReplyManager.class,endpoint.getErrorHandlerLoggingLevel(),endpoint.isErrorHandlerLogStackTrace()));
  }
  if (endpoint.getReceiveTimeout() >= 0) {
    answer.setReceiveTimeout(endpoint.getReceiveTimeout());
  }
  if (endpoint.getRecoveryInterval() >= 0) {
    answer.setRecoveryInterval(endpoint.getRecoveryInterval());
  }
  String name="TemporaryQueueReplyManager[" + answer.getDestinationName() + "]";
  String beanName=endpoint.getCamelContext().getExecutorServiceManager().resolveThreadName(name);
  answer.setBeanName(beanName);
  if (answer.getConcurrentConsumers() > 1) {
    log.info("Using {}-{} concurrent consumers on {}",new Object[]{answer.getConcurrentConsumers(),answer.getMaxConcurrentConsumers(),name});
  }
  return answer;
}
