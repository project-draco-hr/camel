{
  URI u=normalizeUri(uri);
  String scheme=u.getScheme();
  String json=componentJSonSchema(scheme);
  if (json == null) {
    throw new IllegalArgumentException("Cannot find endpoint with scheme " + scheme);
  }
  Map<String,String> userInfoOptions=new LinkedHashMap<String,String>();
  boolean userInfo=false;
  String username=null;
  String password=null;
  if (u.getUserInfo() != null) {
    userInfo=true;
    String[] parts=u.getUserInfo().split(":");
    if (parts.length == 2) {
      username=parts[0];
      password=parts[1];
    }
 else {
      username=u.getUserInfo();
    }
  }
  String syntax=null;
  String alternativeSyntax=null;
  List<Map<String,String>> rows=JSonSchemaHelper.parseJsonSchema("component",json,false);
  for (  Map<String,String> row : rows) {
    if (row.containsKey("syntax")) {
      syntax=row.get("syntax");
    }
    if (row.containsKey("alternativeSyntax")) {
      alternativeSyntax=row.get("alternativeSyntax");
    }
  }
  if (syntax == null) {
    throw new IllegalArgumentException("Endpoint with scheme " + scheme + " has no syntax defined in the json schema");
  }
  syntax=after(syntax,":");
  if (alternativeSyntax != null) {
    alternativeSyntax=after(alternativeSyntax,":");
  }
  uri=after(uri,":");
  String uriPath=stripQuery(uri);
  if (alternativeSyntax != null && alternativeSyntax.contains("@")) {
    int idx=alternativeSyntax.indexOf("@");
    String fields=alternativeSyntax.substring(0,idx);
    String[] names=fields.split(":");
    if (userInfo && names.length == 2) {
      userInfoOptions.put(names[0],username);
      if (password != null) {
        userInfoOptions.put(names[1],password);
      }
    }
  }
  if (userInfo) {
    int idx=uriPath.indexOf('@');
    if (idx > -1) {
      uriPath=uriPath.substring(idx + 1);
    }
  }
  if (uriPath != null && uriPath.startsWith("//")) {
    uriPath=uriPath.substring(2);
  }
  Matcher matcher=SYNTAX_PATTERN.matcher(syntax);
  List<String> word=new ArrayList<String>();
  while (matcher.find()) {
    String s=matcher.group(1);
    if (!scheme.equals(s)) {
      word.add(s);
    }
  }
  String[] tokens=SYNTAX_PATTERN.split(syntax);
  List<String> word2=new ArrayList<String>();
  int prev=0;
  for (  String token : tokens) {
    if (token.isEmpty()) {
      continue;
    }
    int idx=-1;
    int len=0;
    if (":".equals(token)) {
      idx=uriPath.indexOf("://",prev);
      len=3;
    }
    if (idx == -1) {
      idx=uriPath.indexOf(token,prev);
      len=token.length();
    }
    if (idx > 0) {
      String option=uriPath.substring(prev,idx);
      word2.add(option);
      prev=idx + len;
    }
  }
  if (prev > 0 || word2.isEmpty()) {
    String option=uriPath.substring(prev);
    word2.add(option);
  }
  rows=JSonSchemaHelper.parseJsonSchema("properties",json,true);
  boolean defaultValueAdded=false;
  Map<String,String> options=new LinkedHashMap<String,String>();
  if (!userInfoOptions.isEmpty()) {
    options.putAll(userInfoOptions);
  }
  Iterator<String> it=word2.iterator();
  for (int i=0; i < word.size(); i++) {
    String key=word.get(i);
    boolean allOptions=word.size() == word2.size();
    boolean required=isPropertyRequired(rows,key);
    String defaultValue=getPropertyDefaultValue(rows,key);
    if (allOptions) {
      String value=it.next();
      options.put(key,value);
    }
 else {
      if (!required) {
        String value=defaultValue;
        if (value != null) {
          options.put(key,value);
          defaultValueAdded=true;
        }
      }
 else {
        String value=it.hasNext() ? it.next() : null;
        if (value != null) {
          options.put(key,value);
        }
      }
    }
  }
  Map<String,String> answer=new LinkedHashMap<String,String>();
  for (  Map.Entry<String,String> entry : options.entrySet()) {
    String key=entry.getKey();
    String value=entry.getValue();
    if (defaultValueAdded) {
      boolean required=isPropertyRequired(rows,key);
      String defaultValue=getPropertyDefaultValue(rows,key);
      if (!required && defaultValue != null) {
        if (defaultValue.equals(value)) {
          continue;
        }
      }
    }
    answer.put(key,value);
  }
  Map<String,Object> parameters=URISupport.parseParameters(u);
  for (  Map.Entry<String,Object> entry : parameters.entrySet()) {
    String key=entry.getKey();
    String value=entry.getValue() != null ? entry.getValue().toString() : "";
    answer.put(key,value);
  }
  return answer;
}
