{
  URI u=normalizeUri(uri);
  String scheme=u.getScheme();
  String json=componentJSonSchema(scheme);
  if (json == null) {
    throw new IllegalArgumentException("Cannot find endpoint with scheme " + scheme);
  }
  String syntax=null;
  List<Map<String,String>> rows=JSonSchemaHelper.parseJsonSchema("component",json,false);
  for (  Map<String,String> row : rows) {
    if (row.containsKey("syntax")) {
      syntax=row.get("syntax");
      break;
    }
  }
  if (syntax == null) {
    throw new IllegalArgumentException("Endpoint with scheme " + scheme + " has no syntax defined in the json schema");
  }
  syntax=after(syntax,":");
  uri=after(uri,":");
  String uriPath=stripQuery(uri);
  Matcher matcher=SYNTAX_PATTERN.matcher(syntax);
  List<String> word=new ArrayList<String>();
  while (matcher.find()) {
    String s=matcher.group(1);
    if (!scheme.equals(s)) {
      word.add(s);
    }
  }
  String[] tokens=SYNTAX_PATTERN.split(syntax);
  List<String> word2=new ArrayList<String>();
  int prev=0;
  for (  String token : tokens) {
    if (token.isEmpty()) {
      continue;
    }
    int idx=-1;
    int len=0;
    if (":".equals(token)) {
      idx=uriPath.indexOf("://",prev);
      len=3;
    }
    if (idx == -1) {
      idx=uriPath.indexOf(token,prev);
      len=token.length();
    }
    if (idx > 0) {
      String option=uriPath.substring(prev,idx);
      word2.add(option);
      prev=idx + len;
    }
  }
  if (prev > 0 || word2.isEmpty()) {
    String option=uriPath.substring(prev);
    word2.add(option);
  }
  rows=JSonSchemaHelper.parseJsonSchema("properties",json,true);
  boolean defaultValueAdded=false;
  Map<String,String> options=new LinkedHashMap<String,String>();
  Iterator<String> it=word2.iterator();
  for (int i=0; i < word.size(); i++) {
    String key=word.get(i);
    boolean allOptions=word.size() == word2.size();
    boolean required=isPropertyRequired(rows,key);
    String defaultValue=getPropertyDefaultValue(rows,key);
    if (allOptions) {
      String value=it.next();
      options.put(key,value);
    }
 else {
      if (!required) {
        String value=defaultValue;
        if (value != null) {
          options.put(key,value);
          defaultValueAdded=true;
        }
      }
 else {
        String value=it.hasNext() ? it.next() : null;
        if (value != null) {
          options.put(key,value);
        }
      }
    }
  }
  Map<String,String> answer=new LinkedHashMap<String,String>();
  for (  Map.Entry<String,String> entry : options.entrySet()) {
    String key=entry.getKey();
    String value=entry.getValue();
    if (defaultValueAdded) {
      boolean required=isPropertyRequired(rows,key);
      String defaultValue=getPropertyDefaultValue(rows,key);
      if (!required && defaultValue != null) {
        if (defaultValue.equals(value)) {
          continue;
        }
      }
    }
    answer.put(key,value);
  }
  Map<String,Object> parameters=URISupport.parseParameters(u);
  for (  Map.Entry<String,Object> entry : parameters.entrySet()) {
    String key=entry.getKey();
    String value=entry.getValue() != null ? entry.getValue().toString() : "";
    answer.put(key,value);
  }
  return answer;
}
