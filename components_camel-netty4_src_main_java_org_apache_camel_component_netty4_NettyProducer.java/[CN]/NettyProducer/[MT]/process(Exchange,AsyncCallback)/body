{
  if (!isRunAllowed()) {
    if (exchange.getException() == null) {
      exchange.setException(new RejectedExecutionException());
    }
    callback.done(true);
    return true;
  }
  Object body;
  try {
    body=getRequestBody(exchange);
    if (body == null) {
      noReplyLogger.log("No payload to send for exchange: " + exchange);
      callback.done(true);
      return true;
    }
  }
 catch (  Exception e) {
    exchange.setException(e);
    callback.done(true);
    return true;
  }
  if (getConfiguration().getCharsetName() != null) {
    exchange.setProperty(Exchange.CHARSET_NAME,IOHelper.normalizeCharset(getConfiguration().getCharsetName()));
  }
  if (LOG.isTraceEnabled()) {
    LOG.trace("Pool[active={}, idle={}]",pool.getNumActive(),pool.getNumIdle());
  }
  Channel existing;
  try {
    existing=pool.borrowObject();
    if (existing != null) {
      LOG.trace("Got channel from pool {}",existing);
    }
  }
 catch (  Exception e) {
    exchange.setException(e);
    callback.done(true);
    return true;
  }
  if (existing == null) {
    exchange.setException(new CamelExchangeException("Cannot get channel from pool",exchange));
    callback.done(true);
    return true;
  }
  final Channel channel=existing;
  final AsyncCallback producerCallback=new NettyProducerCallback(channel,callback);
  channel.setAttachment(new NettyCamelState(producerCallback,exchange));
  NettyHelper.writeBodyAsync(LOG,channel,null,body,exchange,new ChannelFutureListener(){
    public void operationComplete(    ChannelFuture channelFuture) throws Exception {
      LOG.trace("Operation complete {}",channelFuture);
      if (!channelFuture.isSuccess()) {
        exchange.setException(channelFuture.cause());
        producerCallback.done(false);
        return;
      }
      if (!configuration.isSync()) {
        try {
          Boolean close;
          if (ExchangeHelper.isOutCapable(exchange)) {
            close=exchange.getOut().getHeader(NettyConstants.NETTY_CLOSE_CHANNEL_WHEN_COMPLETE,Boolean.class);
          }
 else {
            close=exchange.getIn().getHeader(NettyConstants.NETTY_CLOSE_CHANNEL_WHEN_COMPLETE,Boolean.class);
          }
          boolean disconnect=getConfiguration().isDisconnect();
          if (close != null) {
            disconnect=close;
          }
          if (disconnect) {
            if (LOG.isTraceEnabled()) {
              LOG.trace("Closing channel when complete at address: {}",getEndpoint().getConfiguration().getAddress());
            }
            NettyHelper.close(channel);
          }
        }
  finally {
          producerCallback.done(false);
        }
      }
    }
  }
);
  return false;
}
