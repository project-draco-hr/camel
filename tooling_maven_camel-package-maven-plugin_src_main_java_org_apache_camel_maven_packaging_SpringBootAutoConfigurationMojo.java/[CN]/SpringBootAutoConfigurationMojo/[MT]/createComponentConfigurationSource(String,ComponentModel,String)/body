{
  final JavaClassSource javaClass=Roaster.create(JavaClassSource.class);
  int pos=model.getJavaType().lastIndexOf(".");
  String name=model.getJavaType().substring(pos + 1);
  name=name.replace("Component","ComponentConfiguration");
  javaClass.setPackage(packageName).setName(name);
  String doc="Generated by camel-package-maven-plugin - do not edit this file!";
  if (!Strings.isBlank(model.getDescription())) {
    doc=model.getDescription() + "\n\n" + doc;
  }
  javaClass.getJavaDoc().setFullText(doc);
  String prefix="camel.component." + (overrideComponentName != null ? overrideComponentName : model.getScheme());
  prefix=prefix.toLowerCase(Locale.US);
  javaClass.addAnnotation("org.springframework.boot.context.properties.ConfigurationProperties").setStringValue("prefix",prefix);
  Set<JavaClassSource> nestedTypes=new HashSet<>();
  for (  ComponentOptionModel option : model.getComponentOptions()) {
    if (skipComponentOption(model,option)) {
      continue;
    }
    String type=option.getJavaType();
    type=getSimpleJavaType(type);
    if (isNestedProperty(type,nestedTypes)) {
      type=option.getShortJavaType() + INNER_TYPE_SUFFIX;
    }
    PropertySource<JavaClassSource> prop=javaClass.addProperty(type,option.getName());
    if (!(type.endsWith(INNER_TYPE_SUFFIX) || !(type.indexOf('[') == -1) || EXCLUDE_INNER_PATTERN.matcher(type).matches()|| !Strings.isBlank(option.getEnumValues()))) {
      prop.getField().addAnnotation(NestedConfigurationProperty.class);
    }
    if ("true".equals(option.getDeprecated())) {
      prop.getField().addAnnotation(Deprecated.class);
      prop.getAccessor().addAnnotation(Deprecated.class);
      prop.getMutator().addAnnotation(Deprecated.class);
      prop.getAccessor().addAnnotation(DeprecatedConfigurationProperty.class);
    }
    if (!Strings.isBlank(option.getDescription())) {
      prop.getField().getJavaDoc().setFullText(option.getDescription());
    }
    if (!Strings.isBlank(option.getDefaultValue())) {
      if ("java.lang.String".equals(option.getJavaType())) {
        prop.getField().setStringInitializer(option.getDefaultValue());
      }
 else       if ("integer".equals(option.getType()) || "boolean".equals(option.getType())) {
        String value=option.getDefaultValue();
        if ("long".equals(option.getJavaType()) && !value.toUpperCase().endsWith("L")) {
          value=value + "L";
        }
        prop.getField().setLiteralInitializer(value);
      }
 else       if (!Strings.isBlank(option.getEnumValues())) {
        String enumShortName=type.substring(type.lastIndexOf(".") + 1);
        prop.getField().setLiteralInitializer(enumShortName + "." + option.getDefaultValue());
        javaClass.addImport(model.getJavaType());
      }
    }
  }
  ClassLoader projectClassLoader=getProjectClassLoader();
  for (  JavaClassSource nestedType : nestedTypes) {
    final JavaClassSource innerClass=javaClass.addNestedType("public static class " + nestedType.getName() + INNER_TYPE_SUFFIX);
    innerClass.addField().setPublic().setStatic(true).setFinal(true).setType(Class.class).setName("CAMEL_NESTED_CLASS").setLiteralInitializer(nestedType.getCanonicalName() + ".class");
    for (    ResolvedProperty resolvedProperty : getProperties(nestedType)) {
      String optionType=resolvedProperty.propertyType;
      PropertySource<JavaClassSource> sourceProp=resolvedProperty.propertySource;
      Type<JavaClassSource> propType=sourceProp.getType();
      final PropertySource<JavaClassSource> prop=innerClass.addProperty(optionType,sourceProp.getName());
      boolean anEnum;
      Class optionClass;
      if (!propType.isArray()) {
        optionClass=loadClass(projectClassLoader,optionType);
        anEnum=optionClass.isEnum();
      }
 else {
        optionClass=null;
        anEnum=false;
      }
      if (!EXCLUDE_INNER_PATTERN.matcher(optionType).matches() && !propType.isArray() && !anEnum) {
        prop.getField().addAnnotation(NestedConfigurationProperty.class);
      }
      if (sourceProp.hasAnnotation(Deprecated.class)) {
        prop.getField().addAnnotation(Deprecated.class);
        prop.getAccessor().addAnnotation(Deprecated.class);
        prop.getMutator().addAnnotation(Deprecated.class);
        prop.getAccessor().addAnnotation(DeprecatedConfigurationProperty.class);
      }
      String description=null;
      final MethodSource<JavaClassSource> mutator=sourceProp.getMutator();
      if (mutator.hasJavaDoc()) {
        description=mutator.getJavaDoc().getFullText();
      }
 else       if (sourceProp.hasField()) {
        description=sourceProp.getField().getJavaDoc().getFullText();
      }
      if (!Strings.isBlank(description)) {
        prop.getField().getJavaDoc().setFullText(description);
      }
      String defaultValue=null;
      if (sourceProp.hasAnnotation(UriParam.class)) {
        defaultValue=sourceProp.getAnnotation(UriParam.class).getStringValue("defaultValue");
      }
 else       if (sourceProp.hasAnnotation(UriPath.class)) {
        defaultValue=sourceProp.getAnnotation(UriPath.class).getStringValue("defaultValue");
      }
      if (!Strings.isBlank(defaultValue)) {
        if ("java.lang.String".equals(optionType)) {
          prop.getField().setStringInitializer(defaultValue);
        }
 else         if ("integer".equals(optionType) || "boolean".equals(optionType)) {
          prop.getField().setLiteralInitializer(defaultValue);
        }
 else         if (anEnum) {
          String enumShortName=optionClass.getSimpleName();
          prop.getField().setLiteralInitializer(enumShortName + "." + defaultValue);
          javaClass.addImport(model.getJavaType());
        }
      }
    }
  }
  sortImports(javaClass);
  String fileName=packageName.replaceAll("\\.","\\/") + "/" + name+ ".java";
  writeSourceIfChanged(javaClass,fileName);
}
