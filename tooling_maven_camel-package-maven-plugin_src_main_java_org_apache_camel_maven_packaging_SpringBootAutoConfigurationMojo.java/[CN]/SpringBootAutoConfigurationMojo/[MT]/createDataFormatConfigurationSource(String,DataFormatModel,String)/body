{
  final JavaClassSource javaClass=Roaster.create(JavaClassSource.class);
  int pos=model.getJavaType().lastIndexOf(".");
  String name=model.getJavaType().substring(pos + 1);
  name=name.replace("DataFormat","DataFormatConfiguration");
  javaClass.setPackage(packageName).setName(name);
  String doc="Generated by camel-package-maven-plugin - do not edit this file!";
  if (!Strings.isBlank(model.getDescription())) {
    doc=model.getDescription() + "\n\n" + doc;
  }
  javaClass.getJavaDoc().setFullText(doc);
  String prefix="camel.dataformat." + (overrideDataFormatName != null ? overrideDataFormatName : model.getName());
  prefix=prefix.toLowerCase(Locale.US);
  javaClass.addAnnotation("org.springframework.boot.context.properties.ConfigurationProperties").setStringValue("prefix",prefix);
  for (  DataFormatOptionModel option : model.getDataFormatOptions()) {
    if ("id".equals(option.getName())) {
      continue;
    }
    String type=option.getJavaType();
    type=type.replaceAll("\\<\\?\\>","");
    if ("boolean".equals(type)) {
      type="java.lang.Boolean";
    }
 else     if ("int".equals(type) || "integer".equals(type)) {
      type="java.lang.Integer";
    }
 else     if ("byte".equals(type)) {
      type="java.lang.Byte";
    }
 else     if ("short".equals(type)) {
      type="java.lang.Short";
    }
 else     if ("double".equals(type)) {
      type="java.lang.Double";
    }
 else     if ("float".equals(type)) {
      type="java.lang.Float";
    }
    PropertySource<JavaClassSource> prop=javaClass.addProperty(type,option.getName());
    if ("true".equals(option.getDeprecated())) {
      prop.getField().addAnnotation(Deprecated.class);
      prop.getAccessor().addAnnotation(Deprecated.class);
      prop.getMutator().addAnnotation(Deprecated.class);
      prop.getAccessor().addAnnotation(DeprecatedConfigurationProperty.class);
    }
    if (!Strings.isBlank(option.getDescription())) {
      prop.getField().getJavaDoc().setFullText(option.getDescription());
    }
    if (!Strings.isBlank(option.getDefaultValue())) {
      if ("java.lang.String".equals(option.getType())) {
        prop.getField().setStringInitializer(option.getDefaultValue());
      }
 else       if ("integer".equals(option.getType()) || "boolean".equals(option.getType())) {
        prop.getField().setLiteralInitializer(option.getDefaultValue());
      }
 else       if (!Strings.isBlank(option.getEnumValues())) {
        String enumShortName=type.substring(type.lastIndexOf(".") + 1);
        prop.getField().setLiteralInitializer(enumShortName + "." + option.getDefaultValue());
        javaClass.addImport(model.getJavaType());
      }
    }
  }
  sortImports(javaClass);
  String fileName=packageName.replaceAll("\\.","\\/") + "/" + name+ ".java";
  File target=new File(srcDir,fileName);
  try {
    InputStream is=getClass().getClassLoader().getResourceAsStream("license-header-java.txt");
    String header=loadText(is);
    String code=sourceToString(javaClass);
    code=header + code;
    getLog().debug("Source code generated:\n" + code);
    if (target.exists()) {
      String existing=FileUtils.readFileToString(target);
      if (!code.equals(existing)) {
        FileUtils.write(target,code,false);
        getLog().info("Updated existing file: " + target);
      }
 else {
        getLog().debug("No changes to existing file: " + target);
      }
    }
 else {
      FileUtils.write(target,code);
      getLog().info("Created file: " + target);
    }
  }
 catch (  Exception e) {
    throw new MojoFailureException("IOError with file " + target,e);
  }
}
