{
  if (socket.isConnected() && !socket.isClosed()) {
    InputStream socketInputStream=MllpUtil.getInputStream(socket);
    ByteArrayOutputStream payload=new ByteArrayOutputStream(4096);
    try {
      while (true) {
        int readByte=socketInputStream.read();
switch (readByte) {
case END_OF_STREAM:
          if (isLogPHIEnabled(log)) {
            log.error("END_OF_STREAM read while looking for the end of the MLLP frame - resetting connection and eating data: {}",payload.toString().replace('\r','\n'));
          }
 else {
            log.error("END_OF_STREAM read while looking for the end of the MLLP frame - resetting connection and eating data");
          }
        resetConnection(socket);
      throw new MllpCorruptFrameException("END_OF_STREAM read while looking for the end of the MLLP frame",payload.size() > 0 ? payload.toByteArray() : null);
case START_OF_BLOCK:
    if (isLogPHIEnabled(log)) {
      log.error("A new MLLP frame was opened before the previous frame was closed - resetting connection and eating data: {}",payload.toString().replace('\r','\n'));
    }
 else {
      log.error("A new MLLP frame was opened before the previous frame was closed - resetting connection and eating data");
    }
  resetConnection(socket);
throw new MllpCorruptFrameException("A new MLLP frame was opened before the previous frame was closed",payload.size() > 0 ? payload.toByteArray() : null);
case END_OF_BLOCK:
if (END_OF_DATA != socketInputStream.read()) {
if (isLogPHIEnabled(log)) {
  log.error("The MLLP frame was partially closed - END_OF_BLOCK was not followed by END_OF_DATA - resetting connection and eating data: {}",payload.toString().replace('\r','\n'));
}
 else {
  log.error("The MLLP frame was partially closed - END_OF_BLOCK was not followed by END_OF_DATA - resetting connection and eating data");
}
resetConnection(socket);
throw new MllpCorruptFrameException("The MLLP frame was partially closed - END_OF_BLOCK was not followed by END_OF_DATA",payload.size() > 0 ? payload.toByteArray() : null);
}
return payload.toByteArray();
default :
payload.write(readByte);
}
}
}
 catch (SocketTimeoutException timeoutEx) {
if (0 < payload.size()) {
if (isLogPHIEnabled(log)) {
log.error("Timeout looking for the end of the MLLP frame - resetting connection and eating data: {}",payload.toString().replace('\r','\n'));
}
 else {
log.error("Timeout looking for the end of the MLLP frame - resetting connection and eating data");
}
}
 else {
log.error("Timeout looking for the end of the MLLP frame - resetting connection");
}
resetConnection(socket);
throw new MllpCorruptFrameException("Timeout looking for the end of the MLLP frame",payload.size() > 0 ? payload.toByteArray() : null,timeoutEx);
}
catch (IOException ioEx) {
if (0 < payload.size()) {
if (isLogPHIEnabled(log)) {
log.error("Exception encountered looking for the end of the MLLP frame - resetting connection and eating data: {}",payload.toString().replace('\r','\n'));
}
 else {
log.error("Exception encountered looking for the end of the MLLP frame - resetting connection and eating data");
}
}
 else {
log.error("Exception encountered looking for the end of the MLLP frame - resetting connection");
}
resetConnection(socket);
throw new MllpException("Exception encountered looking for the end of the MLLP frame",payload.size() > 0 ? payload.toByteArray() : null,ioEx);
}
}
return null;
}
