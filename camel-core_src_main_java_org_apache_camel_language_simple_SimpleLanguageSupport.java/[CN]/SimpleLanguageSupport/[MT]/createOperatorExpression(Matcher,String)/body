{
  int groupCount=matcher.groupCount();
  if (log.isTraceEnabled()) {
    log.trace("Matcher expression: " + expression);
    log.trace("Matcher group count: " + groupCount);
    for (int i=0; i < matcher.groupCount() + 1; i++) {
      String group=matcher.group(i);
      if (log.isTraceEnabled()) {
        log.trace("Matcher group #" + i + ": "+ group);
      }
    }
  }
  String operatorText=matcher.group(6);
  if (operatorText == null) {
    return doCreateOperatorExpression(expression,matcher.group(2),matcher.group(3),matcher.group(4));
  }
 else {
    final Expression first=doCreateOperatorExpression(expression,matcher.group(2),matcher.group(3),matcher.group(4));
    final SimpleLanguageOperator operator=asOperator(operatorText);
    final Expression last=doCreateOperatorExpression(expression,matcher.group(8),matcher.group(9),matcher.group(10));
    final Predicate compoundPredicate;
    if (operator == AND) {
      compoundPredicate=PredicateBuilder.and(PredicateBuilder.toPredicate(first),PredicateBuilder.toPredicate(last));
    }
 else     if (operator == OR) {
      compoundPredicate=PredicateBuilder.or(PredicateBuilder.toPredicate(first),PredicateBuilder.toPredicate(last));
    }
 else {
      throw new IllegalArgumentException("Syntax error in expression: " + expression + ". Expected operator as either and/or but was: "+ operator);
    }
    return new Expression(){
      public <T>T evaluate(      Exchange exchange,      Class<T> type){
        boolean matches=compoundPredicate.matches(exchange);
        return exchange.getContext().getTypeConverter().convertTo(type,matches);
      }
      @Override public String toString(){
        return first + " " + operator+ " "+ last;
      }
    }
;
  }
}
