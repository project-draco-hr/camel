{
  final Expression left=createSimpleExpression(leftText,true);
  final SimpleLanguageOperator operator=asOperator(operatorText);
  final Expression right;
  final Boolean isNull;
  if ("null".equals(rightText) || "'null'".equals(rightText)) {
    isNull=Boolean.TRUE;
    right=createSimpleOrConstantExpression(null);
  }
 else {
    isNull=Boolean.FALSE;
    right=createSimpleOrConstantExpression(rightText);
  }
  return new Expression(){
    public <T>T evaluate(    Exchange exchange,    Class<T> type){
      Predicate predicate=null;
      if (operator == EQ && isNull) {
        predicate=PredicateBuilder.isNull(left);
      }
 else       if (operator == NOT && isNull) {
        predicate=PredicateBuilder.isNotNull(left);
      }
 else       if (operator == EQ) {
        predicate=PredicateBuilder.isEqualTo(left,right);
      }
 else       if (operator == GT) {
        predicate=PredicateBuilder.isGreaterThan(left,right);
      }
 else       if (operator == GTE) {
        predicate=PredicateBuilder.isGreaterThanOrEqualTo(left,right);
      }
 else       if (operator == LT) {
        predicate=PredicateBuilder.isLessThan(left,right);
      }
 else       if (operator == LTE) {
        predicate=PredicateBuilder.isLessThanOrEqualTo(left,right);
      }
 else       if (operator == NOT) {
        predicate=PredicateBuilder.isNotEqualTo(left,right);
      }
 else       if (operator == CONTAINS || operator == NOT_CONTAINS) {
        predicate=PredicateBuilder.contains(left,right);
        if (operator == NOT_CONTAINS) {
          predicate=PredicateBuilder.not(predicate);
        }
      }
 else       if (operator == REGEX || operator == NOT_REGEX) {
        predicate=PredicateBuilder.regex(left,right.evaluate(exchange,String.class));
        if (operator == NOT_REGEX) {
          predicate=PredicateBuilder.not(predicate);
        }
      }
 else       if (operator == IN || operator == NOT_IN) {
        Iterator<Object> it=ObjectHelper.createIterator(right.evaluate(exchange,Object.class));
        List<Object> values=new ArrayList<Object>();
        while (it.hasNext()) {
          values.add(it.next());
        }
        ValueBuilder vb=new ValueBuilder(left);
        predicate=vb.in(values.toArray());
        if (operator == NOT_IN) {
          predicate=PredicateBuilder.not(predicate);
        }
      }
 else       if (operator == IS || operator == NOT_IS) {
        String name=right.evaluate(exchange,String.class);
        Class<?> rightType=exchange.getContext().getClassResolver().resolveClass(name);
        if (rightType == null) {
          throw new IllegalArgumentException("Syntax error in " + operatorText + " operator: "+ expression+ " cannot find class with name: "+ name);
        }
        predicate=PredicateBuilder.isInstanceOf(left,rightType);
        if (operator == NOT_IS) {
          predicate=PredicateBuilder.not(predicate);
        }
      }
 else       if (operator == RANGE || operator == NOT_RANGE) {
        String range=right.evaluate(exchange,String.class);
        Matcher matcher=RANGE_PATTERN.matcher(range);
        if (matcher.matches()) {
          Expression from=ExpressionBuilder.constantExpression(matcher.group(1));
          Expression to=ExpressionBuilder.constantExpression(matcher.group(3));
          predicate=PredicateBuilder.isGreaterThanOrEqualTo(left,from);
          predicate=PredicateBuilder.and(predicate,PredicateBuilder.isLessThanOrEqualTo(left,to));
        }
 else {
          throw new IllegalArgumentException("Syntax error in " + operatorText + " operator: "+ expression+ " is not valid. Valid syntax:from..to(where from and to are numbers).");
        }
        if (operator == NOT_RANGE) {
          predicate=PredicateBuilder.not(predicate);
        }
      }
      if (predicate == null) {
        throw new IllegalArgumentException("Unsupported operator: " + operatorText + " for expression: "+ expression);
      }
      boolean matches=predicate.matches(exchange);
      return exchange.getContext().getTypeConverter().convertTo(type,matches);
    }
    @Override public String toString(){
      return left + " " + operator+ " "+ right;
    }
  }
;
}
