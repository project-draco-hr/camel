{
  List<ApiMethodModel> result=new ArrayList<ApiMethodModel>();
  for (  String signature : signatures) {
    signature=signature.replaceAll(METHOD_PREFIX,"$4 $5(");
    signature=signature.replaceAll("(\\(|,\\s*)final\\s+","$1");
    signature=signature.replaceAll("\\s*<\\s*","<").replaceAll("\\s*>",">");
    log.debug("Processing " + signature);
    final Matcher methodMatcher=METHOD_PATTERN.matcher(signature);
    if (!methodMatcher.matches()) {
      throw new IllegalArgumentException("Invalid method signature " + signature);
    }
    final String resultTypeWithArgs=methodMatcher.group(1);
    final Matcher resultMatcher=GENERIC_ARG_PATTERN.matcher(resultTypeWithArgs);
    final Class<?> resultType=(resultMatcher.matches()) ? forName(resultMatcher.group(1)) : forName(resultTypeWithArgs);
    final String name=methodMatcher.group(2);
    final String argSignature=methodMatcher.group(3);
    final List<Argument> arguments=new ArrayList<Argument>();
    List<Class<?>> argTypes=new ArrayList<Class<?>>();
    final Matcher argsMatcher=ARGS_PATTERN.matcher(argSignature);
    while (argsMatcher.find()) {
      final String argTypeWithParams=argsMatcher.group(1);
      final Matcher genericMatcher=GENERIC_ARG_PATTERN.matcher(argTypeWithParams);
      Class<?> type;
      String typeArgs=null;
      if (genericMatcher.matches()) {
        type=forName(genericMatcher.group(1));
        typeArgs=genericMatcher.group(2);
      }
 else {
        type=forName(argTypeWithParams);
      }
      arguments.add(new Argument(argsMatcher.group(2),type,typeArgs));
      argTypes.add(type);
    }
    Method method;
    try {
      method=proxyType.getMethod(name,argTypes.toArray(new Class<?>[argTypes.size()]));
    }
 catch (    NoSuchMethodException e) {
      throw new IllegalArgumentException("Method not found [" + signature + "] in type "+ proxyType.getName());
    }
    result.add(new ApiMethodModel(name,resultType,arguments,method));
  }
  result=processResults(result);
  Map<String,Class<?>> allArguments=new HashMap<String,Class<?>>();
  for (  ApiMethodModel model : result) {
    for (    Argument argument : model.getArguments()) {
      String name=argument.getName();
      Class<?> argClass=allArguments.get(name);
      Class<?> type=argument.getType();
      if (argClass == null) {
        allArguments.put(name,type);
      }
 else {
        if (argClass != type) {
          throw new IllegalArgumentException("Argument [" + name + "] is used in multiple methods with different types "+ argClass.getCanonicalName()+ ", "+ type.getCanonicalName());
        }
      }
    }
  }
  allArguments.clear();
  Collections.sort(result,new Comparator<ApiMethodModel>(){
    @Override public int compare(    ApiMethodModel model1,    ApiMethodModel model2){
      final int nameCompare=model1.name.compareTo(model2.name);
      if (nameCompare != 0) {
        return nameCompare;
      }
 else {
        final int nArgs1=model1.arguments.size();
        final int nArgsCompare=nArgs1 - model2.arguments.size();
        if (nArgsCompare != 0) {
          return nArgsCompare;
        }
 else {
          for (int i=0; i < nArgs1; i++) {
            final int argCompare=model1.arguments.get(i).name.compareTo(model2.arguments.get(i).name);
            if (argCompare != 0) {
              return argCompare;
            }
          }
          log.warn("Duplicate methods found [" + model1 + "], ["+ model2+ "]");
          return 0;
        }
      }
    }
  }
);
  final Map<String,Integer> dups=new HashMap<String,Integer>();
  for (  ApiMethodModel model : result) {
    final String name=model.getName();
    final char[] upperCase=new char[name.length()];
    final char[] lowerCase=name.toCharArray();
    for (int i=0; i < upperCase.length; i++) {
      upperCase[i]=Character.toUpperCase(lowerCase[i]);
    }
    String uniqueName=new String(upperCase);
    Integer suffix=dups.get(uniqueName);
    if (suffix == null) {
      dups.put(uniqueName,1);
    }
 else {
      dups.put(uniqueName,suffix + 1);
      StringBuilder builder=new StringBuilder(uniqueName);
      builder.append("_").append(suffix);
      uniqueName=builder.toString();
    }
    model.uniqueName=uniqueName;
  }
  return result;
}
