{
  try {
    boolean waitingForStartOfBlock=true;
    while (waitingForStartOfBlock) {
      int potentialStartCharacter=anInputStream.read();
switch (potentialStartCharacter) {
case END_OF_STREAM:
        return null;
case START_OF_BLOCK:
      waitingForStartOfBlock=false;
    break;
default :
  log.warn("START_OF_BLOCK character has not been received.  Out-of-band character received: {}",potentialStartCharacter);
}
}
}
 catch (SocketException socketEx) {
if (clientSocket.isClosed()) {
log.info("Client socket closed while waiting for MLLP_ENVELOPE_START_OF_BLOCK");
}
 else if (clientSocket.isConnected()) {
log.info("SocketException encountered while waiting for MLLP_ENVELOPE_START_OF_BLOCK");
resetConnection(clientSocket);
}
 else {
log.error("Unable to read from socket stream when expected bMLLP_ENVELOPE_START_OF_BLOCK - resetting connection ",socketEx);
resetConnection(clientSocket);
}
return null;
}
boolean endOfMessage=false;
StringBuilder parsedMessage=new StringBuilder(anInputStream.available() + 10);
while (!endOfMessage) {
int characterReceived=anInputStream.read();
switch (characterReceived) {
case START_OF_BLOCK:
log.error("Received START_OF_BLOCK before END_OF_DATA.  Discarding data: {}",parsedMessage.toString());
return null;
case END_OF_STREAM:
log.error("Received END_OF_STREAM without END_OF_DATA.  Discarding data: {}",parsedMessage.toString());
return null;
case END_OF_BLOCK:
characterReceived=anInputStream.read();
if (characterReceived != END_OF_DATA) {
log.error("Received {} when expecting END_OF_DATA after END_OF_BLOCK.  Discarding Hl7MessageGenerator: {}",characterReceived,parsedMessage.toString());
return null;
}
endOfMessage=true;
break;
default :
parsedMessage.append((char)characterReceived);
}
}
return parsedMessage.toString();
}
