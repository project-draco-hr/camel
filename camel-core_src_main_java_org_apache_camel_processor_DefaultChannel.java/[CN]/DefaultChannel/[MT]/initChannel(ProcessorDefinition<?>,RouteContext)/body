{
  this.routeContext=routeContext;
  this.definition=outputDefinition;
  this.camelContext=routeContext.getCamelContext();
  Processor target=nextProcessor;
  Processor next;
  InterceptStrategy managed=routeContext.getManagedInterceptStrategy();
  if (managed != null) {
    next=target == nextProcessor ? null : nextProcessor;
    target=managed.wrapProcessorInInterceptors(routeContext.getCamelContext(),outputDefinition,target,next);
  }
  ProcessorDefinition<?> traceDef=childDefinition != null ? childDefinition : outputDefinition;
  TraceInterceptor trace=(TraceInterceptor)getOrCreateTracer().wrapProcessorInInterceptors(routeContext.getCamelContext(),traceDef,target,null);
  trace.setRouteContext(routeContext);
  target=trace;
  for (  InterceptStrategy strategy : interceptors) {
    next=target == nextProcessor ? null : nextProcessor;
    if (strategy instanceof Tracer) {
      continue;
    }
    target=strategy.wrapProcessorInInterceptors(routeContext.getCamelContext(),outputDefinition,target,next);
    if (!(target instanceof AsyncProcessor)) {
      LOG.warn("Interceptor: " + strategy + " at: "+ outputDefinition+ " does not return an AsyncProcessor instance."+ " This causes the asynchronous routing engine to not work as optimal as possible."+ " See more details at the InterceptStrategy javadoc.");
    }
  }
  output=target;
}
