{
  this.routeContext=routeContext;
  this.definition=outputDefinition;
  this.camelContext=routeContext.getCamelContext();
  Processor target=nextProcessor;
  Processor next;
  InterceptStrategy managed=routeContext.getManagedInterceptStrategy();
  if (managed != null) {
    next=target == nextProcessor ? null : nextProcessor;
    target=managed.wrapProcessorInInterceptors(routeContext.getCamelContext(),outputDefinition,target,next);
  }
  ProcessorDefinition<?> traceDef=childDefinition != null ? childDefinition : outputDefinition;
  TraceInterceptor trace=(TraceInterceptor)getOrCreateTracer().wrapProcessorInInterceptors(routeContext.getCamelContext(),traceDef,target,null);
  trace.setRouteContext(routeContext);
  target=trace;
  Collections.sort(interceptors,new OrderedComparator());
  Collections.reverse(interceptors);
  for (  InterceptStrategy strategy : interceptors) {
    next=target == nextProcessor ? null : nextProcessor;
    if (strategy instanceof Tracer) {
      continue;
    }
    Processor wrapped=strategy.wrapProcessorInInterceptors(routeContext.getCamelContext(),outputDefinition,target,next);
    if (!(wrapped instanceof AsyncProcessor)) {
      LOG.warn("Interceptor: " + strategy + " at: "+ outputDefinition+ " does not return an AsyncProcessor instance."+ " This causes the asynchronous routing engine to not work as optimal as possible."+ " See more details at the InterceptStrategy javadoc."+ " Camel will use a bridge to adapt the interceptor to the asynchronous routing engine,"+ " but its not the most optimal solution. Please consider changing your interceptor to comply.");
      InterceptorToAsyncProcessorBridge bridge=new InterceptorToAsyncProcessorBridge(target);
      wrapped=strategy.wrapProcessorInInterceptors(routeContext.getCamelContext(),outputDefinition,bridge,next);
      bridge.setTarget(wrapped);
      wrapped=bridge;
    }
    target=wrapped;
  }
  output=target;
}
