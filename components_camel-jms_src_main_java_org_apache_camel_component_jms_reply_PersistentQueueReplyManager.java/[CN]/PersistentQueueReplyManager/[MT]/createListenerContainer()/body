{
  DefaultMessageListenerContainer answer;
  ReplyToType type=endpoint.getConfiguration().getReplyToType();
  if (type == null) {
    type=ReplyToType.Shared;
  }
  if (ReplyToType.Shared == type) {
    String replyToSelectorName=endpoint.getReplyToDestinationSelectorName();
    if (replyToSelectorName != null) {
      replyToSelectorValue="ID:" + new BigInteger(24 * 8,new Random()).toString(16);
      String fixedMessageSelector=replyToSelectorName + "='" + replyToSelectorValue+ "'";
      answer=new SharedPersistentQueueMessageListenerContainer(fixedMessageSelector);
      answer.setCacheLevel(DefaultMessageListenerContainer.CACHE_CONSUMER);
      log.debug("Using shared queue: " + endpoint.getReplyTo() + " with fixed message selector ["+ fixedMessageSelector+ "] as reply listener: "+ answer);
    }
 else {
      dynamicMessageSelector=new MessageSelectorCreator(correlation);
      answer=new SharedPersistentQueueMessageListenerContainer(dynamicMessageSelector);
      answer.setCacheLevel(DefaultMessageListenerContainer.CACHE_SESSION);
      log.debug("Using shared queue: " + endpoint.getReplyTo() + " with dynamic message selector as reply listener: "+ answer);
    }
  }
 else   if (ReplyToType.Exclusive == type) {
    answer=new ExclusivePersistentQueueMessageListenerContainer();
    answer.setCacheLevel(DefaultMessageListenerContainer.CACHE_CONSUMER);
    log.debug("Using exclusive queue:" + endpoint.getReplyTo() + " as reply listener: "+ answer);
  }
 else {
    throw new IllegalArgumentException("ReplyToType " + type + " is not supported for persistent reply queues");
  }
  String replyToCacheLevelName=endpoint.getConfiguration().getReplyToCacheLevelName();
  if (replyToCacheLevelName != null) {
    answer.setCacheLevelName(replyToCacheLevelName);
    log.debug("Setting the replyCacheLevel to be " + replyToCacheLevelName);
  }
  DestinationResolver resolver=endpoint.getDestinationResolver();
  if (resolver == null) {
    resolver=answer.getDestinationResolver();
  }
  answer.setDestinationResolver(new DestinationResolverDelegate(resolver));
  answer.setDestinationName(endpoint.getReplyTo());
  answer.setAutoStartup(true);
  answer.setMessageListener(this);
  answer.setPubSubDomain(false);
  answer.setSubscriptionDurable(false);
  answer.setConcurrentConsumers(1);
  answer.setMaxConcurrentConsumers(1);
  answer.setConnectionFactory(endpoint.getConnectionFactory());
  String clientId=endpoint.getClientId();
  if (clientId != null) {
    clientId+=".CamelReplyManager";
    answer.setClientId(clientId);
  }
  answer.setSessionTransacted(false);
  if (endpoint.getExceptionListener() != null) {
    answer.setExceptionListener(endpoint.getExceptionListener());
  }
  if (endpoint.getErrorHandler() != null) {
    answer.setErrorHandler(endpoint.getErrorHandler());
  }
 else {
    answer.setErrorHandler(new DefaultSpringErrorHandler(PersistentQueueReplyManager.class,endpoint.getErrorHandlerLoggingLevel(),endpoint.isErrorHandlerLogStackTrace()));
  }
  if (endpoint.getReceiveTimeout() >= 0) {
    answer.setReceiveTimeout(endpoint.getReceiveTimeout());
  }
  if (endpoint.getRecoveryInterval() >= 0) {
    answer.setRecoveryInterval(endpoint.getRecoveryInterval());
  }
  String name="PersistentQueueReplyManager[" + answer.getDestinationName() + "]";
  name=endpoint.getCamelContext().getExecutorServiceManager().resolveThreadName(name);
  answer.setBeanName(name);
  return answer;
}
