{
  Iterator<Processor> processors=next().iterator();
  final Object existing=exchange.getProperty(Exchange.FILTER_MATCHED);
  final AsyncCallback choiceCallback=new AsyncCallback(){
    @Override public void done(    boolean doneSync){
      if (existing != null) {
        exchange.setProperty(Exchange.FILTER_MATCHED,existing);
      }
 else {
        exchange.removeProperty(Exchange.FILTER_MATCHED);
      }
      callback.done(doneSync);
    }
  }
;
  while (processors.hasNext()) {
    Processor processor=processors.next();
    boolean matches=true;
    if (processor instanceof FilterProcessor) {
      FilterProcessor filter=(FilterProcessor)processor;
      try {
        matches=filter.getPredicate().matches(exchange);
        exchange.setProperty(Exchange.FILTER_MATCHED,matches);
        processor=filter.getProcessor();
      }
 catch (      Throwable e) {
        exchange.setException(e);
      }
    }
    if (!continueProcessing(exchange,"so breaking out of choice",LOG)) {
      break;
    }
    if (!matches) {
      continue;
    }
    AsyncProcessor async=AsyncProcessorConverterHelper.convert(processor);
    return async.process(exchange,choiceCallback);
  }
  choiceCallback.done(true);
  return true;
}
