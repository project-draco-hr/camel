{
  if (doneSync) {
    return;
  }
  while (shouldFailOver(exchange)) {
    attempts.incrementAndGet();
    if (maximumFailoverAttempts > -1 && attempts.get() > maximumFailoverAttempts) {
      if (log.isDebugEnabled()) {
        log.debug("Braking out of failover after " + attempts + " failover attempts");
      }
      break;
    }
    index.incrementAndGet();
    counter.incrementAndGet();
    if (index.get() >= processors.size()) {
      if (isRoundRobin()) {
        log.debug("Failover is round robin enabled and therefore starting from the first endpoint");
        index.set(0);
        counter.set(0);
      }
 else {
        log.debug("Braking out of failover as we reach the end of endpoints to use for failover");
        break;
      }
    }
    prepareExchangeForFailover(exchange);
    Processor processor=processors.get(index.get());
    doneSync=processExchange(processor,exchange,attempts,index,callback,processors);
    if (!doneSync) {
      if (log.isTraceEnabled()) {
        log.trace("Processing exchangeId: " + exchange.getExchangeId() + " is continued being processed asynchronously");
      }
      return;
    }
  }
  callback.done(false);
}
