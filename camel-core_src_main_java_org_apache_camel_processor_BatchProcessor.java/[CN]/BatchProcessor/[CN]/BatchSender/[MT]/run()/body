{
  queueLock.lock();
  try {
    do {
      try {
        if (!exchangeEnqueued) {
          if (LOG.isTraceEnabled()) {
            LOG.trace("Waiting for new exchange to arrive or batchTimeout to occur after " + batchTimeout + " ms.");
          }
          exchangeEnqueuedCondition.await(batchTimeout,TimeUnit.MILLISECONDS);
        }
        String id=null;
        if (!completionPredicateMatched.isEmpty()) {
          id=completionPredicateMatched.poll();
        }
        if (id != null || !exchangeEnqueued) {
          if (LOG.isTraceEnabled()) {
            if (id != null) {
              LOG.trace("Collecting exchanges to be aggregated triggered by completion predicate");
            }
 else {
              LOG.trace("Collecting exchanges to be aggregated triggered by batch timeout");
            }
          }
          drainQueueTo(collection,batchSize,id);
        }
 else {
          exchangeEnqueued=false;
          boolean drained=false;
          while (isInBatchCompleted(queue.size())) {
            drained=true;
            drainQueueTo(collection,batchSize,id);
          }
          if (drained) {
            LOG.trace("Collecting exchanges to be aggregated triggered by new exchanges received");
          }
          if (!isOutBatchCompleted()) {
            continue;
          }
        }
        queueLock.unlock();
        try {
          try {
            sendExchanges();
          }
 catch (          Throwable t) {
            getExceptionHandler().handleException(new CamelException(t));
          }
        }
  finally {
          queueLock.lock();
        }
      }
 catch (      InterruptedException e) {
        break;
      }
    }
 while (isRunAllowed());
  }
  finally {
    queueLock.unlock();
  }
}
