{
  retry.set(0);
  onExceptionRetry.set(0);
  context.addRoutes(new RouteBuilder(){
    @Override public void configure() throws Exception {
      deadLetterChannel("mock:error").redeliveryDelay(0).maximumRedeliveries(3);
      onException(IOException.class).maximumRedeliveries(3).handled(true).to("mock:b").process(new Processor(){
        @Override public void process(        Exchange exchange) throws Exception {
          onExceptionRetry.incrementAndGet();
        }
      }
).to("mock:c");
      from("direct:start").to("direct:intermediate").to("mock:result");
      from("direct:intermediate").to("mock:a").process(new Processor(){
        @Override public void process(        Exchange exchange) throws Exception {
          retry.incrementAndGet();
          throw new IOException("IO error");
        }
      }
).to("mock:end");
    }
  }
);
  context.start();
  getMockEndpoint("mock:a").expectedMessageCount(1);
  getMockEndpoint("mock:b").expectedMessageCount(1);
  getMockEndpoint("mock:c").expectedMessageCount(1);
  getMockEndpoint("mock:result").expectedMessageCount(0);
  getMockEndpoint("mock:end").expectedMessageCount(0);
  getMockEndpoint("mock:error").expectedMessageCount(0);
  template.sendBody("direct:start","Hello World");
  assertMockEndpointsSatisfied();
  assertEquals("Should try 4 times (1 first, 3 retry)",4,retry.get());
  assertEquals("Should only invoke onException once",1,onExceptionRetry.get());
}
