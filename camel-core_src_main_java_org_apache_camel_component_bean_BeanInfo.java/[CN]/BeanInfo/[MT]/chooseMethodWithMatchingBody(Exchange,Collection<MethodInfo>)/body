{
  Message in=exchange.getIn();
  Object body=in.getBody();
  if (body != null) {
    Class bodyType=body.getClass();
    if (LOG.isTraceEnabled()) {
      LOG.trace("Matching for method with a single parameter that matches type: " + bodyType.getCanonicalName());
    }
    List<MethodInfo> possibles=new ArrayList<MethodInfo>();
    for (    MethodInfo methodInfo : operationList) {
      boolean out=exchange.getPattern().isOutCapable();
      if (out && methodInfo.isReturnTypeVoid()) {
        continue;
      }
      if (methodInfo.bodyParameterMatches(bodyType)) {
        possibles.add(methodInfo);
      }
    }
    if (possibles.size() == 1) {
      return possibles.get(0);
    }
 else     if (possibles.isEmpty()) {
      Object newBody=null;
      MethodInfo matched=null;
      for (      MethodInfo methodInfo : operationList) {
        Object value=null;
        try {
          value=convertToType(exchange,methodInfo.getBodyParameterType(),body);
          if (value != null) {
            if (newBody != null) {
              throw new AmbiguousMethodCallException(exchange,Arrays.asList(matched,methodInfo));
            }
 else {
              newBody=value;
              matched=methodInfo;
            }
          }
        }
 catch (        NoTypeConversionAvailableException e) {
        }
      }
      if (matched != null) {
        in.setBody(newBody);
        return matched;
      }
    }
 else {
      if (operationsWithCustomAnnotation.size() == 1) {
        return operationsWithCustomAnnotation.get(0);
      }
      return chooseMethodWithCustomAnnotations(exchange,possibles);
    }
  }
  return null;
}
