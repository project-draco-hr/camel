{
  Exception exception=ExpressionBuilder.exchangeExceptionExpression().evaluate(exchange,Exception.class);
  if (exception != null && possiblesWithException.size() == 1) {
    LOG.trace("Exchange has exception set so we prefer method that also has exception as parameter");
    return possiblesWithException.get(0);
  }
 else   if (possibles.size() == 1) {
    return possibles.get(0);
  }
 else   if (possibles.isEmpty()) {
    LOG.trace("No possible methods so now trying to convert body to parameter types");
    Object newBody=null;
    MethodInfo matched=null;
    int matchCounter=0;
    for (    MethodInfo methodInfo : operationList) {
      if (methodInfo.getBodyParameterType().isInstance(body)) {
        return methodInfo;
      }
      Object value=exchange.getContext().getTypeConverter().tryConvertTo(methodInfo.getBodyParameterType(),exchange,body);
      if (value != null) {
        if (LOG.isTraceEnabled()) {
          LOG.trace("Converted body from: {} to: {}",body.getClass().getCanonicalName(),methodInfo.getBodyParameterType().getCanonicalName());
        }
        matchCounter++;
        newBody=value;
        matched=methodInfo;
      }
    }
    if (matchCounter > 1) {
      throw new AmbiguousMethodCallException(exchange,Arrays.asList(matched,matched));
    }
    if (matched != null) {
      LOG.trace("Setting converted body: {}",body);
      Message in=exchange.getIn();
      in.setBody(newBody);
      return matched;
    }
  }
 else {
    if (possibleWithCustomAnnotation.size() == 1) {
      MethodInfo answer=possibleWithCustomAnnotation.get(0);
      LOG.trace("There are only one method with annotations so we choose it: {}",answer);
      return answer;
    }
    MethodInfo chosen=chooseMethodWithCustomAnnotations(exchange,possibles);
    if (chosen != null) {
      return chosen;
    }
    chosen=getSingleCovariantMethod(possibles);
    if (chosen != null) {
      return chosen;
    }
    throw new AmbiguousMethodCallException(exchange,possibles);
  }
  return null;
}
