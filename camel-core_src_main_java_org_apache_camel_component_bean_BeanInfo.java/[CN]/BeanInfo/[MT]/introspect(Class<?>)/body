{
  clazz=getTargetClass(clazz);
  ObjectHelper.notNull(clazz,"clazz",this);
  LOG.trace("Introspecting class: {}",clazz);
  List<Method> methods;
  if (Modifier.isPublic(clazz.getModifiers())) {
    LOG.trace("Preferring class methods as class: {} is public accessible",clazz);
    methods=new ArrayList<Method>(Arrays.asList(clazz.getDeclaredMethods()));
  }
 else {
    LOG.trace("Preferring interface methods as class: {} is not public accessible",clazz);
    methods=getInterfaceMethods(clazz);
    List<Method> extraMethods=Arrays.asList(clazz.getDeclaredMethods());
    methods.addAll(extraMethods);
  }
  Set<Method> overrides=new HashSet<Method>();
  for (  Method source : methods) {
    for (    Method target : methods) {
      if (ObjectHelper.isOverridingMethod(source,target,true)) {
        continue;
      }
      if (ObjectHelper.isOverridingMethod(source,target,false)) {
        overrides.add(target);
      }
    }
  }
  methods.removeAll(overrides);
  overrides.clear();
  if (Modifier.isPublic(clazz.getModifiers())) {
    List<Method> extraMethods=getInterfaceMethods(clazz);
    for (    Method target : extraMethods) {
      for (      Method source : methods) {
        if (ObjectHelper.isOverridingMethod(source,target,false)) {
          overrides.add(target);
        }
      }
    }
    extraMethods.removeAll(overrides);
    methods.addAll(extraMethods);
  }
  for (  Method method : methods) {
    boolean valid=isValidMethod(clazz,method);
    LOG.trace("Method: {} is valid: {}",method,valid);
    if (valid) {
      introspect(clazz,method);
    }
  }
  Class<?> superclass=clazz.getSuperclass();
  if (superclass != null && !superclass.equals(Object.class)) {
    introspect(superclass);
  }
}
