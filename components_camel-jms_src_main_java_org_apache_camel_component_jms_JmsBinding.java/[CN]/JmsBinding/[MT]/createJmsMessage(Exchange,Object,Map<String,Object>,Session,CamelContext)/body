{
  JmsMessageType type=null;
  if (endpoint != null && endpoint.isTransferExchange()) {
    LOG.trace("Option transferExchange=true so we use JmsMessageType: Object");
    Serializable holder=DefaultExchangeHolder.marshal(exchange);
    return session.createObjectMessage(holder);
  }
  if (endpoint != null && endpoint.getMessageConverter() != null) {
    if (LOG.isTraceEnabled()) {
      LOG.trace("Creating JmsMessage using a custom MessageConverter: {} with body: {}",endpoint.getMessageConverter(),body);
    }
    return endpoint.getMessageConverter().toMessage(body,session);
  }
  if (headers.containsKey(JmsConstants.JMS_MESSAGE_TYPE)) {
    type=context.getTypeConverter().convertTo(JmsMessageType.class,headers.get(JmsConstants.JMS_MESSAGE_TYPE));
  }
 else   if (endpoint != null && endpoint.getConfiguration().getJmsMessageType() != null) {
    type=endpoint.getConfiguration().getJmsMessageType();
  }
 else {
    type=getJMSMessageTypeForBody(exchange,body,headers,session,context);
  }
  if (type != null) {
    LOG.trace("Using JmsMessageType: {}",type);
    return createJmsMessageForType(exchange,body,headers,session,context,type);
  }
  if (body != null && LOG.isWarnEnabled()) {
    LOG.warn("Cannot determine specific JmsMessage type to use from body class." + " Will use generic JmsMessage." + " Body class: " + ObjectHelper.classCanonicalName(body) + ". If you want to send a POJO then your class might need to implement java.io.Serializable"+ ", or you can force a specific type by setting the jmsMessageType option on the JMS endpoint.");
  }
  return session.createMessage();
}
