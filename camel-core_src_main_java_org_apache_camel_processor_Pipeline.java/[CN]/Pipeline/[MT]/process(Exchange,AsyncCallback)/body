{
  Iterator<Processor> processors=getProcessors().iterator();
  Exchange nextExchange=original;
  boolean first=true;
  while (true) {
    boolean handledException=Boolean.TRUE.equals(nextExchange.getProperty(Exchange.EXCEPTION_HANDLED_PROPERTY));
    if (nextExchange.isFailed() || handledException) {
      if (LOG.isDebugEnabled()) {
        LOG.debug("Message exchange has failed so breaking out of pipeline: " + nextExchange + " exception: "+ nextExchange.getException()+ " fault: "+ nextExchange.getFault(false)+ (handledException ? " handled by the error handler" : ""));
      }
      break;
    }
    if (!processors.hasNext()) {
      break;
    }
    AsyncProcessor processor=AsyncProcessorTypeConverter.convert(processors.next());
    if (first) {
      first=false;
    }
 else {
      nextExchange=createNextExchange(processor,nextExchange);
    }
    boolean sync=process(original,nextExchange,callback,processors,processor);
    if (!sync) {
      return false;
    }
  }
  ExchangeHelper.copyResults(original,nextExchange);
  callback.done(true);
  return true;
}
