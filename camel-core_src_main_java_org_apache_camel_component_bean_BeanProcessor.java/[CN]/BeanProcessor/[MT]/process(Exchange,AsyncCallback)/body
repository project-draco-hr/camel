{
  String explicitMethodName=exchange.getIn().getHeader(Exchange.BEAN_METHOD_NAME,method,String.class);
  Object bean;
  BeanInfo beanInfo;
  try {
    bean=beanHolder.getBean();
    beanInfo=beanHolder.getBeanInfo();
  }
 catch (  Throwable e) {
    exchange.setException(e);
    callback.done(true);
    return true;
  }
  Processor processor=getProcessor();
  if (explicitMethodName == null && processor != null) {
    LOG.trace("Using a custom adapter as bean invocation: {}",processor);
    try {
      processor.process(exchange);
    }
 catch (    Throwable e) {
      exchange.setException(e);
    }
    callback.done(true);
    return true;
  }
  Message in=exchange.getIn();
  BeanInvocation beanInvoke=null;
  if (in.getBody() != null && in.getBody() instanceof BeanInvocation) {
    beanInvoke=(BeanInvocation)in.getBody();
  }
  if (beanInvoke != null) {
    LOG.trace("Exchange IN body is a BeanInvocation instance: {}",beanInvoke);
    Class<?> clazz=beanInvoke.getMethod().getDeclaringClass();
    boolean sameBean=clazz.isInstance(bean);
    if (LOG.isDebugEnabled()) {
      LOG.debug("BeanHolder bean: {} and beanInvocation bean: {} is same instance: {}",new Object[]{bean.getClass(),clazz,sameBean});
    }
    if (sameBean) {
      beanInvoke.invoke(bean,exchange);
      exchange.getOut().getHeaders().putAll(exchange.getIn().getHeaders());
      callback.done(true);
      return true;
    }
  }
  if (in.getHeader(Exchange.BEAN_MULTI_PARAMETER_ARRAY) == null) {
    in.setHeader(Exchange.BEAN_MULTI_PARAMETER_ARRAY,isMultiParameterArray());
  }
  MethodInvocation invocation;
  if (methodObject != null) {
    invocation=beanInfo.createInvocation(methodObject,bean,exchange);
  }
 else {
    if (explicitMethodName != null) {
      in.setHeader(Exchange.BEAN_METHOD_NAME,explicitMethodName);
    }
    try {
      invocation=beanInfo.createInvocation(bean,exchange);
    }
 catch (    Throwable e) {
      exchange.setException(e);
      callback.done(true);
      return true;
    }
  }
  if (invocation == null) {
    throw new IllegalStateException("No method invocation could be created, no matching method could be found on: " + bean);
  }
  in.removeHeader(Exchange.BEAN_MULTI_PARAMETER_ARRAY);
  in.removeHeader(Exchange.BEAN_METHOD_NAME);
  Object value=null;
  try {
    AtomicBoolean sync=new AtomicBoolean(true);
    value=invocation.proceed(callback,sync);
    if (!sync.get()) {
      LOG.trace("Processing exchangeId: {} is continued being processed asynchronously",exchange.getExchangeId());
      return false;
    }
    LOG.trace("Processing exchangeId: {} is continued being processed synchronously",exchange.getExchangeId());
  }
 catch (  InvocationTargetException e) {
    exchange.setException(e.getCause());
    callback.done(true);
    return true;
  }
catch (  Throwable e) {
    exchange.setException(e);
    callback.done(true);
    return true;
  }
  if (!invocation.getMethod().getReturnType().equals(Void.TYPE) && value != Void.TYPE) {
    if (exchange.getPattern().isOutCapable()) {
      LOG.debug("Setting bean invocation result on the OUT message: {}",value);
      exchange.getOut().setBody(value);
      exchange.getOut().getHeaders().putAll(exchange.getIn().getHeaders());
    }
 else {
      LOG.debug("Setting bean invocation result on the IN message: {}",value);
      exchange.getIn().setBody(value);
    }
  }
  callback.done(true);
  return true;
}
