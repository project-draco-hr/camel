{
  String contentType=message.getHeader(Exchange.CONTENT_TYPE,String.class);
  if (contentType != null && HttpConstants.CONTENT_TYPE_JAVA_SERIALIZED_OBJECT.equals(contentType)) {
    try {
      Object object=message.getMandatoryBody(Serializable.class);
      HttpHelper.writeObjectToServletResponse(response,object);
      return;
    }
 catch (    InvalidPayloadException e) {
      throw new IOException(e);
    }
  }
  InputStream is=null;
  if (checkChunked(message,exchange)) {
    is=message.getBody(InputStream.class);
  }
 else {
    if (!isText(contentType)) {
      is=exchange.getContext().getTypeConverter().tryConvertTo(InputStream.class,message.getBody());
    }
  }
  if (is != null) {
    ServletOutputStream os=response.getOutputStream();
    LOG.trace("Writing direct response from source input stream to servlet output stream");
    if (!checkChunked(message,exchange)) {
      CachedOutputStream stream=new CachedOutputStream(exchange);
      try {
        int len=IOHelper.copy(is,stream);
        response.setContentLength(len);
        copyStream(stream.getInputStream(),os);
      }
  finally {
        IOHelper.close(is,stream);
      }
    }
 else {
      copyStream(is,os);
    }
  }
 else {
    String data=message.getBody(String.class);
    if (data != null) {
      LOG.debug("Cannot write from source input stream, falling back to using String content. For binary content this can be a problem.");
      String charset=IOHelper.getCharsetName(exchange,true);
      final int dataByteLength=data.getBytes(charset).length;
      response.setCharacterEncoding(charset);
      response.setContentLength(dataByteLength);
      try {
        response.getWriter().print(data);
      }
  finally {
        response.getWriter().flush();
      }
    }
  }
}
