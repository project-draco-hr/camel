{
  AtomicInteger total=new AtomicInteger();
  Iterator<ProcessorExchangePair> it=pairs.iterator();
  while (it.hasNext()) {
    ProcessorExchangePair pair=it.next();
    Exchange subExchange=pair.getExchange();
    updateNewExchange(subExchange,total.get(),pairs,it);
    boolean sync=doProcessSequential(original,result,pairs,it,pair,callback,total);
    if (!sync) {
      if (LOG.isTraceEnabled()) {
        LOG.trace("Processing exchangeId: " + pair.getExchange().getExchangeId() + " is continued being processed asynchronously");
      }
      return false;
    }
    if (LOG.isTraceEnabled()) {
      LOG.trace("Processing exchangeId: " + pair.getExchange().getExchangeId() + " is continued being processed synchronously");
    }
    boolean continueProcessing=PipelineHelper.continueProcessing(subExchange,"Sequential processing failed for number " + total.get(),LOG);
    if (stopOnException && !continueProcessing) {
      if (subExchange.getException() != null) {
        throw new CamelExchangeException("Sequential processing failed for number " + total.get(),subExchange,subExchange.getException());
      }
 else {
        result.set(subExchange);
        return true;
      }
    }
    if (LOG.isTraceEnabled()) {
      LOG.trace("Sequential processing complete for number " + total + " exchange: "+ subExchange);
    }
    doAggregate(getAggregationStrategy(subExchange),result,subExchange);
    total.incrementAndGet();
  }
  if (LOG.isDebugEnabled()) {
    LOG.debug("Done sequential processing " + total + " exchanges");
  }
  return true;
}
