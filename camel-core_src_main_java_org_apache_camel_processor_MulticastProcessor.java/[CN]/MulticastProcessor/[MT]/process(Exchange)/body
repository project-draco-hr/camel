{
  final AtomicExchange result=new AtomicExchange();
  Iterable<ProcessorExchangePair> pairs=createProcessorExchangePairs(exchange);
  if (isParallelProcessing) {
    List<Exchange> exchanges=new LinkedList<Exchange>();
    final CountingLatch completedExchanges=new CountingLatch();
    int i=0;
    for (    ProcessorExchangePair pair : pairs) {
      Processor producer=pair.getProcessor();
      final Exchange subExchange=pair.getExchange();
      updateNewExchange(subExchange,i,pairs);
      exchanges.add(subExchange);
      completedExchanges.increment();
      ProcessCall call=new ProcessCall(subExchange,producer,new AsyncCallback(){
        public void done(        boolean doneSynchronously){
          if (streaming && aggregationStrategy != null) {
            doAggregate(result,subExchange);
          }
          completedExchanges.decrement();
        }
      }
);
      executor.execute(call);
      i++;
    }
    completedExchanges.await();
    if (!streaming && aggregationStrategy != null) {
      for (      Exchange resultExchange : exchanges) {
        doAggregate(result,resultExchange);
      }
    }
  }
 else {
    int i=0;
    for (    ProcessorExchangePair pair : pairs) {
      Processor producer=pair.getProcessor();
      Exchange subExchange=pair.getExchange();
      updateNewExchange(subExchange,i,pairs);
      producer.process(subExchange);
      doAggregate(result,subExchange);
      i++;
    }
  }
  if (result.get() != null) {
    ExchangeHelper.copyResults(exchange,result.get());
  }
}
