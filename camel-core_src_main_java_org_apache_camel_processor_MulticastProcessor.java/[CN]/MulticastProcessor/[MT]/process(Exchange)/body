{
  Exchange result=null;
  Iterable<ProcessorExchangePair> pairs=createProcessorExchangePairs(exchange);
  if (isParallelProcessing) {
    List<Exchange> exchanges=new LinkedList<Exchange>();
    final CountingLatch completedExchanges=new CountingLatch();
    int i=0;
    for (    ProcessorExchangePair pair : pairs) {
      Processor producer=pair.getProcessor();
      Exchange subExchange=pair.getExchange();
      updateNewExchange(subExchange,i,pairs);
      exchanges.add(subExchange);
      completedExchanges.increment();
      ProcessCall call=new ProcessCall(subExchange,producer,new AsyncCallback(){
        public void done(        boolean doneSynchronously){
          completedExchanges.decrement();
        }
      }
);
      executor.execute(call);
      i++;
    }
    completedExchanges.await();
    if (aggregationStrategy != null) {
      for (      Exchange resultExchange : exchanges) {
        if (result == null) {
          result=resultExchange;
        }
 else {
          result=aggregationStrategy.aggregate(result,resultExchange);
        }
      }
    }
  }
 else {
    int i=0;
    for (    ProcessorExchangePair pair : pairs) {
      Processor producer=pair.getProcessor();
      Exchange subExchange=pair.getExchange();
      updateNewExchange(subExchange,i,pairs);
      producer.process(subExchange);
      if (aggregationStrategy != null) {
        if (result == null) {
          result=subExchange;
        }
 else {
          result=aggregationStrategy.aggregate(result,subExchange);
        }
      }
      i++;
    }
  }
  if (result != null) {
    ExchangeHelper.copyResults(exchange,result);
  }
}
