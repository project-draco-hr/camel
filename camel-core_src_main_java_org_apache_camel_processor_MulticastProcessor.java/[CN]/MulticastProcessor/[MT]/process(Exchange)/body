{
  Exchange result=null;
  Iterable<ProcessorExchangePair> pairs=createProcessorExchangePairs(exchange);
  if (isParallelProcessing) {
    List<ProcessorExchangePair> allPairs=CollectionConverter.toList(pairs);
    Exchange[] exchanges=new Exchange[allPairs.size()];
    final CountDownLatch completedExchanges=new CountDownLatch(allPairs.size());
    int i=0;
    for (    ProcessorExchangePair pair : pairs) {
      Processor producer=pair.getProcessor();
      exchanges[i]=pair.getExchange();
      updateNewExchange(exchanges[i],i,allPairs);
      ProcessCall call=new ProcessCall(exchanges[i],producer,new AsyncCallback(){
        public void done(        boolean doneSynchronously){
          completedExchanges.countDown();
        }
      }
);
      executor.execute(call);
      i++;
    }
    completedExchanges.await();
    if (aggregationStrategy != null) {
      for (      Exchange resultExchange : exchanges) {
        if (result == null) {
          result=resultExchange;
        }
 else {
          result=aggregationStrategy.aggregate(result,resultExchange);
        }
      }
    }
  }
 else {
    int i=0;
    for (    ProcessorExchangePair pair : pairs) {
      Processor producer=pair.getProcessor();
      Exchange subExchange=pair.getExchange();
      updateNewExchange(subExchange,i,pairs);
      producer.process(subExchange);
      if (aggregationStrategy != null) {
        if (result == null) {
          result=subExchange;
        }
 else {
          result=aggregationStrategy.aggregate(result,subExchange);
        }
      }
      i++;
    }
  }
  if (result != null) {
    ExchangeHelper.copyResults(exchange,result);
  }
}
