{
  final CompletionService<Exchange> completion;
  final AtomicBoolean running=new AtomicBoolean(true);
  if (streaming) {
    completion=new ExecutorCompletionService<Exchange>(executorService);
  }
 else {
    completion=new SubmitOrderedCompletionService<Exchange>(executorService);
  }
  final AtomicInteger total=new AtomicInteger(0);
  final Iterator<ProcessorExchangePair> it=pairs.iterator();
  while (it.hasNext()) {
    final ProcessorExchangePair pair=it.next();
    final Exchange subExchange=pair.getExchange();
    updateNewExchange(subExchange,total.intValue(),pairs,it);
    Future<Exchange> task=completion.submit(new Callable<Exchange>(){
      public Exchange call() throws Exception {
        if (!running.get()) {
          return subExchange;
        }
        try {
          doProcessParallel(pair);
        }
 catch (        Throwable e) {
          subExchange.setException(e);
        }
        boolean continueProcessing=PipelineHelper.continueProcessing(subExchange,"Parallel processing failed for number " + total.get(),LOG);
        if (stopOnException && !continueProcessing) {
          if (subExchange.getException() != null) {
            throw new CamelExchangeException("Parallel processing failed for number " + total.get(),subExchange,subExchange.getException());
          }
          running.set(false);
        }
        if (LOG.isTraceEnabled()) {
          LOG.trace("Parallel processing complete for exchange: " + subExchange);
        }
        return subExchange;
      }
    }
);
    total.incrementAndGet();
  }
  boolean timedOut=false;
  boolean stoppedOnException=false;
  final StopWatch watch=new StopWatch();
  for (int i=0; i < total.intValue(); i++) {
    Future<Exchange> future;
    if (timedOut) {
      future=completion.poll();
    }
 else     if (timeout > 0) {
      long left=timeout - watch.taken();
      if (left < 0) {
        left=0;
      }
      if (LOG.isTraceEnabled()) {
        LOG.trace("Polling completion task #" + i + " using timeout "+ left+ " millis.");
      }
      future=completion.poll(left,TimeUnit.MILLISECONDS);
    }
 else {
      if (LOG.isTraceEnabled()) {
        LOG.trace("Polling completion task #" + i);
      }
      future=completion.take();
    }
    if (future == null && timedOut) {
      break;
    }
 else     if (future == null) {
      AggregationStrategy strategy=getAggregationStrategy(null);
      if (strategy instanceof TimeoutAwareAggregationStrategy) {
        Exchange oldExchange=result.get();
        if (oldExchange == null) {
          oldExchange=original;
        }
        ((TimeoutAwareAggregationStrategy)strategy).timeout(oldExchange,i,total.intValue(),timeout);
      }
 else {
        LOG.warn("Parallel processing timed out after " + timeout + " millis for number "+ i+ ". This task will be cancelled and will not be aggregated.");
      }
      timedOut=true;
    }
 else {
      Exchange subExchange=future.get();
      boolean continueProcessing=PipelineHelper.continueProcessing(subExchange,"Parallel processing failed for number " + total.get(),LOG);
      if (stopOnException && !continueProcessing) {
        result.set(subExchange);
        stoppedOnException=true;
        break;
      }
      AggregationStrategy strategy=getAggregationStrategy(subExchange);
      doAggregate(strategy,result,subExchange);
    }
  }
  if (timedOut || stoppedOnException) {
    if (timedOut && LOG.isDebugEnabled()) {
      LOG.debug("Cancelling tasks due timeout after " + timeout + " millis.");
    }
    if (stoppedOnException && LOG.isDebugEnabled()) {
      LOG.debug("Cancelling tasks due stopOnException.");
    }
    running.set(false);
  }
  if (LOG.isDebugEnabled()) {
    LOG.debug("Done parallel processing " + total + " exchanges");
  }
}
