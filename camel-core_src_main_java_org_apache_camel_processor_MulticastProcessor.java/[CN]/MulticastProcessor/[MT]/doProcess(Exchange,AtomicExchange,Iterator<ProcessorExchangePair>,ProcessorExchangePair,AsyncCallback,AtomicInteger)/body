{
  boolean sync=true;
  final Exchange exchange=pair.getExchange();
  Processor processor=pair.getProcessor();
  Producer producer=pair.getProducer();
  TracedRouteNodes traced=exchange.getUnitOfWork() != null ? exchange.getUnitOfWork().getTracedRouteNodes() : null;
  StopWatch watch=null;
  if (producer != null) {
    watch=new StopWatch();
  }
  try {
    if (traced != null) {
      traced.pushBlock();
    }
    AsyncProcessor async=AsyncProcessorTypeConverter.convert(processor);
    pair.begin();
    sync=async.process(exchange,new AsyncCallback(){
      public void done(      boolean doneSync){
        pair.done();
        if (doneSync) {
          return;
        }
        Exchange subExchange=exchange;
        if (stopOnException && subExchange.getException() != null) {
          subExchange.setException(new CamelExchangeException("Sequential processing failed for number " + total,subExchange,subExchange.getException()));
          exchange.setProperty(Exchange.REDELIVERY_EXHAUSTED,Boolean.TRUE);
          original.removeProperty(Exchange.AGGREGATION_STRATEGY);
          ExchangeHelper.copyResults(original,subExchange);
          callback.done(false);
          return;
        }
        try {
          doAggregate(getAggregationStrategy(subExchange),result,subExchange);
        }
 catch (        Throwable e) {
          subExchange.setException(new CamelExchangeException("Sequential processing failed for number " + total,subExchange,e));
          original.setProperty(Exchange.REDELIVERY_EXHAUSTED,Boolean.TRUE);
          original.removeProperty(Exchange.AGGREGATION_STRATEGY);
          ExchangeHelper.copyResults(original,subExchange);
          callback.done(false);
          return;
        }
        total.incrementAndGet();
        while (it.hasNext()) {
          ProcessorExchangePair pair=it.next();
          subExchange=pair.getExchange();
          updateNewExchange(subExchange,total.get(),null);
          boolean sync=doProcess(original,result,it,pair,callback,total);
          if (!sync) {
            if (LOG.isTraceEnabled()) {
              LOG.trace("Processing exchangeId: " + original.getExchangeId() + " is continued being processed asynchronously");
            }
            return;
          }
          if (stopOnException && subExchange.getException() != null) {
            subExchange.setException(new CamelExchangeException("Sequential processing failed for number " + total,subExchange,subExchange.getException()));
            original.setProperty(Exchange.REDELIVERY_EXHAUSTED,Boolean.TRUE);
            original.removeProperty(Exchange.AGGREGATION_STRATEGY);
            ExchangeHelper.copyResults(original,subExchange);
            callback.done(false);
            return;
          }
          try {
            doAggregate(getAggregationStrategy(subExchange),result,subExchange);
          }
 catch (          Throwable e) {
            subExchange.setException(new CamelExchangeException("Sequential processing failed for number " + total,subExchange,e));
            original.setProperty(Exchange.REDELIVERY_EXHAUSTED,Boolean.TRUE);
            original.removeProperty(Exchange.AGGREGATION_STRATEGY);
            ExchangeHelper.copyResults(original,subExchange);
            callback.done(false);
            return;
          }
          total.incrementAndGet();
        }
        original.removeProperty(Exchange.AGGREGATION_STRATEGY);
        if (result.get() != null) {
          ExchangeHelper.copyResults(original,result.get());
        }
        callback.done(false);
      }
    }
);
  }
  finally {
    if (traced != null) {
      traced.popBlock();
    }
    if (producer != null) {
      long timeTaken=watch.stop();
      Endpoint endpoint=producer.getEndpoint();
      EventHelper.notifyExchangeSent(exchange.getContext(),exchange,endpoint,timeTaken);
    }
  }
  return sync;
}
