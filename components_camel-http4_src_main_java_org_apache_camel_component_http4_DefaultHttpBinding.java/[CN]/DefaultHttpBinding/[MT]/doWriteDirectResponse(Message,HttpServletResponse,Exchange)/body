{
  String contentType=message.getHeader(Exchange.CONTENT_TYPE,String.class);
  if (contentType != null && HttpConstants.CONTENT_TYPE_JAVA_SERIALIZED_OBJECT.equals(contentType)) {
    try {
      Object object=message.getMandatoryBody(Serializable.class);
      HttpHelper.writeObjectToServletResponse(response,object);
      return;
    }
 catch (    InvalidPayloadException e) {
      throw new IOException(e);
    }
  }
  InputStream is;
  if (checkChunked(message,exchange)) {
    is=message.getBody(InputStream.class);
  }
 else {
    is=exchange.getContext().getTypeConverter().tryConvertTo(InputStream.class,message.getBody());
  }
  if (is != null) {
    ServletOutputStream os=response.getOutputStream();
    try {
      LOG.trace("Writing direct response from source input stream to servlet output stream");
      IOHelper.copy(is,os);
    }
  finally {
      IOHelper.close(os,is);
    }
  }
 else {
    String data=message.getBody(String.class);
    if (data != null) {
      LOG.debug("Cannot write from source input stream, falling back to using String content. For binary content this can be a problem.");
      String charset=IOHelper.getCharsetName(exchange,true);
      final int dataByteLength=data.getBytes(charset).length;
      response.setCharacterEncoding(charset);
      response.setContentLength(dataByteLength);
      try {
        response.getWriter().print(data);
      }
  finally {
        response.getWriter().flush();
      }
    }
  }
}
