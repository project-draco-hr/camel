{
  bindListener(any(),new TypeListener(){
    Provider<? extends AnnotationMemberProvider> providerProvider;
    public <I>void hear(    TypeLiteral<I> injectableType,    TypeEncounter<I> encounter){
      Set<Field> boundFields=Sets.newHashSet();
      Map<MethodKey,Method> boundMethods=Maps.newHashMap();
      TypeLiteral<?> startType=injectableType;
      while (true) {
        Class<?> type=startType.getRawType();
        if (type == Object.class) {
          break;
        }
        Field[] fields=type.getDeclaredFields();
        for (        Field field : fields) {
          if (boundFields.add(field)) {
            bindAnnotationInjectorToField(encounter,startType,field);
          }
        }
        Method[] methods=type.getDeclaredMethods();
        for (        final Method method : methods) {
          MethodKey key=new MethodKey(method);
          if (boundMethods.get(key) == null) {
            boundMethods.put(key,method);
            bindAnnotationInjectionToMember(encounter,startType,method);
          }
        }
        Class<?> supertype=type.getSuperclass();
        if (supertype == Object.class) {
          break;
        }
        startType=startType.getSupertype(supertype);
      }
    }
    protected <I>void bindAnnotationInjectionToMember(    final TypeEncounter<I> encounter,    final TypeLiteral<?> type,    final Method method){
      final A annotation=method.getAnnotation(annotationType);
      if (annotation != null) {
        if (providerProvider == null) {
          providerProvider=memberProviderProvider.get(encounter);
        }
        encounter.register(new MembersInjector<I>(){
          public void injectMembers(          I injectee){
            AnnotationMemberProvider provider=providerProvider.get();
            int size=method.getParameterTypes().length;
            Object[] values=new Object[size];
            for (int i=0; i < size; i++) {
              Class<?> paramType=getParameterType(type,method,i);
              Object value=provider.provide(annotation,type,method,paramType,i);
              checkInjectedValueType(value,paramType,encounter);
              if (value == null && !provider.isNullParameterAllowed(annotation,method,paramType,i)) {
                return;
              }
              values[i]=value;
            }
            try {
              method.setAccessible(true);
              method.invoke(injectee,values);
            }
 catch (            IllegalAccessException e) {
              throw new ProvisionException("Failed to inject method " + method + ". Reason: "+ e,e);
            }
catch (            InvocationTargetException ie) {
              Throwable e=ie.getTargetException();
              throw new ProvisionException("Failed to inject method " + method + ". Reason: "+ e,e);
            }
          }
        }
);
      }
    }
    protected <I>void bindAnnotationInjectorToField(    final TypeEncounter<I> encounter,    final TypeLiteral<?> type,    final Field field){
      final A annotation=field.getAnnotation(annotationType);
      if (annotation != null) {
        if (providerProvider == null) {
          providerProvider=memberProviderProvider.get(encounter);
        }
        encounter.register(new InjectionListener<I>(){
          public void afterInjection(          I injectee){
            AnnotationMemberProvider provider=providerProvider.get();
            Object value=provider.provide(annotation,type,field);
            checkInjectedValueType(value,field.getType(),encounter);
            try {
              field.setAccessible(true);
              field.set(injectee,value);
            }
 catch (            IllegalAccessException e) {
              throw new ProvisionException("Failed to inject field " + field + ". Reason: "+ e,e);
            }
          }
        }
);
      }
    }
  }
);
}
