{
  boolean sync=true;
  Exception caught=exchange.getException();
  exchange.setException(null);
  final boolean shouldHandle=shouldHandle(exchange,data);
  final boolean shouldContinue=shouldContinue(exchange,data);
  boolean handled=false;
  boolean handleOrContinue=isDeadLetterChannel || shouldHandle || shouldContinue;
  if (handleOrContinue) {
    exchange.getIn().removeHeader(Exchange.REDELIVERED);
    exchange.getIn().removeHeader(Exchange.REDELIVERY_COUNTER);
    exchange.getIn().removeHeader(Exchange.REDELIVERY_MAX_COUNTER);
    exchange.removeProperty(Exchange.REDELIVERY_EXHAUSTED);
    exchange.removeProperty(Exchange.ROLLBACK_ONLY);
    exchange.removeProperty(Exchange.UNIT_OF_WORK_EXHAUSTED);
    handled=true;
  }
 else {
    decrementRedeliveryCounter(exchange);
  }
  if (processor != null) {
    if (data.useOriginalInMessage) {
      log.trace("Using the original IN message instead of current");
      Message original=exchange.getUnitOfWork().getOriginalInMessage();
      exchange.setIn(original);
      if (exchange.hasOut()) {
        log.trace("Removing the out message to avoid some uncertain behavior");
        exchange.setOut(null);
      }
    }
    MessageHelper.resetStreamCache(exchange.getIn());
    if (onPrepare != null) {
      try {
        log.trace("OnPrepare processor {} is processing Exchange: {}",onPrepare,exchange);
        onPrepare.process(exchange);
      }
 catch (      Exception e) {
        exchange.setException(e);
      }
    }
    log.trace("Failure processor {} is processing Exchange: {}",processor,exchange);
    exchange.setProperty(Exchange.FAILURE_ENDPOINT,exchange.getProperty(Exchange.TO_ENDPOINT));
    UnitOfWork uow=exchange.getUnitOfWork();
    if (uow != null && uow.getRouteContext() != null) {
      exchange.setProperty(Exchange.FAILURE_ROUTE_ID,uow.getRouteContext().getRoute().getId());
    }
    final boolean deadLetterChannel=processor == data.deadLetterProcessor;
    EventHelper.notifyExchangeFailureHandling(exchange.getContext(),exchange,processor,deadLetterChannel,deadLetterUri);
    AsyncProcessor afp=AsyncProcessorConverterHelper.convert(processor);
    sync=afp.process(exchange,new AsyncCallback(){
      public void done(      boolean sync){
        log.trace("Failure processor done: {} processing Exchange: {}",processor,exchange);
        try {
          prepareExchangeAfterFailure(exchange,data,isDeadLetterChannel,shouldHandle,shouldContinue);
          EventHelper.notifyExchangeFailureHandled(exchange.getContext(),exchange,processor,deadLetterChannel,deadLetterUri);
        }
  finally {
          data.sync&=sync;
          callback.done(data.sync);
        }
      }
    }
);
  }
 else {
    try {
      if (onPrepare != null) {
        try {
          log.trace("OnPrepare processor {} is processing Exchange: {}",onPrepare,exchange);
          onPrepare.process(exchange);
        }
 catch (        Exception e) {
          exchange.setException(e);
        }
      }
      prepareExchangeAfterFailure(exchange,data,isDeadLetterChannel,shouldHandle,shouldContinue);
    }
  finally {
      callback.done(data.sync);
    }
  }
  String msg="Failed delivery for " + ExchangeHelper.logIds(exchange);
  msg=msg + ". Exhausted after delivery attempt: " + data.redeliveryCounter+ " caught: "+ caught;
  if (processor != null) {
    if (isDeadLetterChannel && deadLetterUri != null) {
      msg=msg + ". Handled by DeadLetterChannel: [" + URISupport.sanitizeUri(deadLetterUri)+ "]";
    }
 else {
      msg=msg + ". Processed by failure processor: " + processor;
    }
  }
  logFailedDelivery(false,false,handled,false,isDeadLetterChannel,exchange,msg,data,null);
  return sync;
}
