{
  data.original=defensiveCopyExchange(exchange);
  while (true) {
    if (!isRunAllowed()) {
      if (exchange.getException() == null) {
        exchange.setException(new RejectedExecutionException());
      }
      callback.done(data.sync);
      return data.sync;
    }
    boolean handle=shouldHandleException(exchange);
    if (handle) {
      handleException(exchange,data);
    }
    boolean exhausted=isExhausted(exchange,data);
    if (exhausted) {
      Processor target=null;
      boolean deliver=true;
      SubUnitOfWorkCallback uowCallback=exchange.getUnitOfWork().getSubUnitOfWorkCallback();
      if (uowCallback != null) {
        uowCallback.onExhausted(exchange);
        deliver=false;
      }
      if (deliver) {
        target=data.failureProcessor != null ? data.failureProcessor : data.deadLetterProcessor;
      }
      boolean sync=deliverToFailureProcessor(target,exchange,data,callback);
      return sync;
    }
    if (data.redeliveryCounter > 0) {
      data.redeliveryDelay=data.currentRedeliveryPolicy.calculateRedeliveryDelay(data.redeliveryDelay,data.redeliveryCounter);
      if (data.redeliveryDelay > 0) {
        if (data.currentRedeliveryPolicy.isAsyncDelayedRedelivery() && !exchange.isTransacted()) {
          data.sync=false;
          data.redeliverFromSync=true;
          AsyncRedeliveryTask task=new AsyncRedeliveryTask(exchange,callback,data);
          if (log.isTraceEnabled()) {
            log.trace("Scheduling redelivery task to run in {} millis for exchangeId: {}",data.redeliveryDelay,exchange.getExchangeId());
          }
          executorService.schedule(task,data.redeliveryDelay,TimeUnit.MILLISECONDS);
          return false;
        }
 else {
          try {
            data.currentRedeliveryPolicy.sleep(data.redeliveryDelay);
          }
 catch (          InterruptedException e) {
            exchange.setException(e);
            exchange.setProperty(Exchange.ROUTE_STOP,Boolean.TRUE);
            callback.done(data.sync);
            return data.sync;
          }
        }
      }
      prepareExchangeForRedelivery(exchange,data);
      deliverToOnRedeliveryProcessor(exchange,data);
      EventHelper.notifyExchangeRedelivery(exchange.getContext(),exchange,data.redeliveryCounter);
    }
    boolean sync=AsyncProcessorHelper.process(outputAsync,exchange,new AsyncCallback(){
      public void done(      boolean sync){
        if (sync) {
          return;
        }
        data.sync=false;
        if (isDone(exchange)) {
          callback.done(sync);
          return;
        }
        processAsyncErrorHandler(exchange,callback,data);
      }
    }
);
    if (!sync) {
      return false;
    }
    boolean done=isDone(exchange);
    if (done) {
      callback.done(true);
      return true;
    }
  }
}
