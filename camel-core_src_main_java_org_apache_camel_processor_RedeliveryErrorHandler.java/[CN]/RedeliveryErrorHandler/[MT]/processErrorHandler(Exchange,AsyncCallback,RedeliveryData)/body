{
  while (true) {
    boolean handle=shouldHandleException(exchange);
    if (handle) {
      handleException(exchange,data);
    }
    boolean shouldRedeliver=shouldRedeliver(exchange,data);
    if (!shouldRedeliver) {
      Processor target=data.failureProcessor != null ? data.failureProcessor : data.deadLetterProcessor;
      deliverToFailureProcessor(target,exchange,data);
      prepareExchangeAfterFailure(exchange,data);
      if (target != null) {
        boolean deadLetterChannel=target == data.deadLetterProcessor && data.deadLetterProcessor != null;
        EventHelper.notifyExchangeFailureHandled(exchange.getContext(),exchange,target,deadLetterChannel);
      }
      boolean shouldContinue=shouldContinue(exchange,data);
      if (shouldContinue) {
        prepareExchangeForContinue(exchange,data);
      }
      return data.sync;
    }
    if (shouldRedeliver && data.redeliveryCounter > 0) {
      prepareExchangeForRedelivery(exchange);
      try {
        data.redeliveryDelay=data.currentRedeliveryPolicy.sleep(data.redeliveryDelay,data.redeliveryCounter);
      }
 catch (      InterruptedException e) {
        if (log.isDebugEnabled()) {
          log.debug("Sleep interrupted, are we stopping? " + (isStopping() || isStopped()));
        }
        continue;
      }
      deliverToRedeliveryProcessor(exchange,data);
    }
    boolean sync=outputAsync.process(exchange,new AsyncCallback(){
      public void done(      boolean sync){
        if (sync) {
          return;
        }
        data.sync=false;
        if (!isDone(exchange)) {
        }
 else {
          callback.done(sync);
        }
      }
    }
);
    if (!sync) {
      return false;
    }
    boolean done=isDone(exchange);
    if (done) {
      callback.done(true);
      return true;
    }
  }
}
