{
  DefaultInflightRepository toTest=new DefaultInflightRepository();
  Endpoint[] endpoints=new Endpoint[TOTAL_ENDPOINTS];
  for (int i=0; i < endpoints.length; i++) {
    Endpoint endpoint=new DefaultEndpoint(){
      final String uri="def:" + System.nanoTime();
      @Override public String getEndpointUri(){
        return uri;
      }
      public boolean isSingleton(){
        return false;
      }
      public Producer createProducer() throws Exception {
        return null;
      }
      public Consumer createConsumer(      Processor processor) throws Exception {
        return null;
      }
    }
;
    endpoints[i]=endpoint;
  }
  AtomicInteger locker=new AtomicInteger();
  Thread[] threads=new Thread[THREAD_COUNT];
  for (int i=0; i < threads.length; i++) {
    threads[i]=new Thread(new TypicalConsumer(endpoints,toTest,locker));
  }
  for (int i=0; i < threads.length; i++) {
    threads[i].start();
  }
  Thread.sleep(1000);
  while (locker.get() > 0) {
synchronized (locker) {
      locker.wait();
    }
  }
  if (failed) {
    throw new AssertionError("Failed to properly track endpoints");
  }
  for (  Endpoint endpoint : endpoints) {
    Assert.assertEquals("Size MUST be 0",0,toTest.size(endpoint));
  }
  if (toTest.size() > 0) {
    throw new AssertionError("Test either incomplete or tracking failed");
  }
  Assert.assertEquals("Must not have any references left",0,toTest.endpointSize());
}
