{
  String sigKeyFileName=findSignatureKeyFileName(exchange);
  String sigKeyUserid=findSignatureKeyUserid(exchange);
  String sigKeyPassword=findSignatureKeyPassword(exchange);
  byte[] sigKeyRing=findSignatureKeyRing(exchange);
  if ((sigKeyFileName == null && sigKeyRing == null) || sigKeyUserid == null || sigKeyPassword == null) {
    return null;
  }
  PGPSecretKey sigSecretKey=PGPDataFormatUtil.findSecretKey(exchange.getContext(),sigKeyFileName,sigKeyRing,sigKeyPassword,sigKeyUserid,getProvider());
  if (sigSecretKey == null) {
    throw new IllegalArgumentException(String.format("Cannot PGP encrypt message. No secret key found for User ID %s. Either add a key with this User ID to the secret keyring or change the configured User ID.",sigKeyUserid));
  }
  PGPPrivateKey sigPrivateKey=sigSecretKey.extractPrivateKey(new JcePBESecretKeyDecryptorBuilder().setProvider(getProvider()).build(sigKeyPassword.toCharArray()));
  if (sigPrivateKey == null) {
    throw new IllegalArgumentException("Signature private key is null, cannot proceed");
  }
  PGPSignatureSubpacketGenerator spGen=new PGPSignatureSubpacketGenerator();
  spGen.setSignerUserID(false,sigKeyUserid);
  int algorithm=sigSecretKey.getPublicKey().getAlgorithm();
  PGPSignatureGenerator sigGen=new PGPSignatureGenerator(new JcaPGPContentSignerBuilder(algorithm,findHashAlgorithm(exchange)).setProvider(getProvider()));
  sigGen.init(PGPSignature.BINARY_DOCUMENT,sigPrivateKey);
  sigGen.setHashedSubpackets(spGen.generate());
  sigGen.generateOnePassVersion(false).encode(out);
  return sigGen;
}
