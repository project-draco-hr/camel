{
  if (encryptedStream == null) {
    return null;
  }
  InputStream in;
  try {
    byte[] encryptedData=IOUtils.toByteArray(encryptedStream);
    InputStream byteStream=new ByteArrayInputStream(encryptedData);
    in=PGPUtil.getDecoderStream(byteStream);
  }
  finally {
    IOUtils.closeQuietly(encryptedStream);
  }
  PGPObjectFactory pgpFactory=new PGPObjectFactory(in);
  Object o=pgpFactory.nextObject();
  PGPEncryptedDataList enc;
  if (o instanceof PGPEncryptedDataList) {
    enc=(PGPEncryptedDataList)o;
  }
 else {
    enc=(PGPEncryptedDataList)pgpFactory.nextObject();
  }
  IOHelper.close(in);
  PGPPublicKeyEncryptedData pbe=null;
  PGPPrivateKey key=null;
  for (int i=0; i < enc.size() && key == null; i++) {
    pbe=(PGPPublicKeyEncryptedData)enc.get(i);
    key=PGPDataFormatUtil.findPrivateKeyWithKeyId(exchange.getContext(),findKeyFileName(exchange),findEncryptionKeyRing(exchange),pbe.getKeyID(),findKeyPassword(exchange),getPassphraseAccessor(),getProvider());
  }
  if (key == null) {
    throw new PGPException("Provided input is encrypted with unknown pair of keys.");
  }
  InputStream encData=pbe.getDataStream(new JcePublicKeyDataDecryptorFactoryBuilder().setProvider(getProvider()).build(key));
  pgpFactory=new PGPObjectFactory(encData);
  PGPCompressedData comData=(PGPCompressedData)pgpFactory.nextObject();
  pgpFactory=new PGPObjectFactory(comData.getDataStream());
  Object object=pgpFactory.nextObject();
  PGPOnePassSignature signature;
  if (object instanceof PGPOnePassSignatureList) {
    signature=getSignature(exchange,(PGPOnePassSignatureList)object);
    object=pgpFactory.nextObject();
  }
 else {
    signature=null;
  }
  PGPLiteralData ld=(PGPLiteralData)object;
  InputStream litData=ld.getInputStream();
  byte[] answer;
  try {
    answer=Streams.readAll(litData);
  }
  finally {
    IOHelper.close(litData,encData,in);
  }
  if (signature != null) {
    signature.update(answer);
    PGPSignatureList sigList=(PGPSignatureList)pgpFactory.nextObject();
    if (!signature.verify(getSignatureWithKeyId(signature.getKeyID(),sigList))) {
      throw new SignatureException("Cannot verify PGP signature");
    }
  }
  return answer;
}
