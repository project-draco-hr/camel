{
  PGPPublicKey key=PGPDataFormatUtil.findPublicKey(exchange.getContext(),findKeyFileName(exchange),findEncryptionKeyRing(exchange),findKeyUserid(exchange),true);
  if (key == null) {
    throw new IllegalArgumentException("Public key is null, cannot proceed");
  }
  InputStream input=ExchangeHelper.convertToMandatoryType(exchange,InputStream.class,graph);
  if (armored) {
    outputStream=new ArmoredOutputStream(outputStream);
  }
  PGPEncryptedDataGenerator encGen=new PGPEncryptedDataGenerator(new JcePGPDataEncryptorBuilder(SymmetricKeyAlgorithmTags.CAST5).setWithIntegrityPacket(integrity).setSecureRandom(new SecureRandom()).setProvider(getProvider()));
  encGen.addMethod(new JcePublicKeyKeyEncryptionMethodGenerator(key));
  OutputStream encOut=encGen.open(outputStream,new byte[BUFFER_SIZE]);
  PGPCompressedDataGenerator comData=new PGPCompressedDataGenerator(CompressionAlgorithmTags.ZIP);
  OutputStream comOut=new BufferedOutputStream(comData.open(encOut));
  PGPSignatureGenerator sigGen=createSignatureGenerator(exchange,comOut);
  PGPLiteralDataGenerator litData=new PGPLiteralDataGenerator();
  String fileName=exchange.getIn().getHeader(Exchange.FILE_NAME,String.class);
  if (ObjectHelper.isEmpty(fileName)) {
    fileName=PGPLiteralData.CONSOLE;
  }
  OutputStream litOut=litData.open(comOut,PGPLiteralData.BINARY,fileName,new Date(),new byte[BUFFER_SIZE]);
  try {
    byte[] buffer=new byte[BUFFER_SIZE];
    int bytesRead;
    while ((bytesRead=input.read(buffer)) != -1) {
      litOut.write(buffer,0,bytesRead);
      if (sigGen != null) {
        sigGen.update(buffer,0,bytesRead);
      }
      litOut.flush();
    }
  }
  finally {
    IOHelper.close(litOut);
    if (sigGen != null) {
      sigGen.generate().encode(comOut);
    }
    IOHelper.close(comOut,encOut,outputStream,input);
  }
}
