{
  List<String> userids=determineEncryptionUserIds(exchange);
  List<PGPPublicKey> keys=PGPDataFormatUtil.findPublicKeys(exchange.getContext(),findKeyFileName(exchange),findEncryptionKeyRing(exchange),userids,true);
  if (keys.isEmpty()) {
    throw new IllegalArgumentException("Cannot PGP encrypt message. No public encryption key found for the User Ids " + userids + " in the public keyring. Either specify other User IDs or add correct public keys to the keyring.");
  }
  InputStream input=ExchangeHelper.convertToMandatoryType(exchange,InputStream.class,graph);
  if (armored) {
    outputStream=new ArmoredOutputStream(outputStream);
  }
  PGPEncryptedDataGenerator encGen=new PGPEncryptedDataGenerator(new JcePGPDataEncryptorBuilder(findAlgorithm(exchange)).setWithIntegrityPacket(integrity).setSecureRandom(new SecureRandom()).setProvider(getProvider()));
  for (  PGPPublicKey key : keys) {
    encGen.addMethod(new JcePublicKeyKeyEncryptionMethodGenerator(key));
  }
  OutputStream encOut=encGen.open(outputStream,new byte[BUFFER_SIZE]);
  PGPCompressedDataGenerator comData=new PGPCompressedDataGenerator(findCompressionAlgorithm(exchange));
  OutputStream comOut=new BufferedOutputStream(comData.open(encOut));
  List<PGPSignatureGenerator> sigGens=createSignatureGenerator(exchange,comOut);
  PGPLiteralDataGenerator litData=new PGPLiteralDataGenerator();
  String fileName=exchange.getIn().getHeader(Exchange.FILE_NAME,String.class);
  if (ObjectHelper.isEmpty(fileName)) {
    fileName=PGPLiteralData.CONSOLE;
  }
  OutputStream litOut=litData.open(comOut,PGPLiteralData.BINARY,fileName,new Date(),new byte[BUFFER_SIZE]);
  try {
    byte[] buffer=new byte[BUFFER_SIZE];
    int bytesRead;
    while ((bytesRead=input.read(buffer)) != -1) {
      litOut.write(buffer,0,bytesRead);
      if (sigGens != null && !sigGens.isEmpty()) {
        for (        PGPSignatureGenerator sigGen : sigGens) {
          sigGen.update(buffer,0,bytesRead);
        }
      }
      litOut.flush();
    }
  }
  finally {
    IOHelper.close(litOut);
    if (sigGens != null && !sigGens.isEmpty()) {
      for (int i=sigGens.size() - 1; i > -1; i--) {
        PGPSignatureGenerator sigGen=sigGens.get(i);
        sigGen.generate().encode(comOut);
      }
    }
    IOHelper.close(comOut,encOut,outputStream,input);
  }
}
