{
  final int size=parameters.size();
  LOG.trace("Creating parameters expression for {} parameters",size);
  final Expression[] expressions=new Expression[size];
  for (int i=0; i < size; i++) {
    Expression parameterExpression=parameters.get(i).getExpression();
    expressions[i]=parameterExpression;
    LOG.trace("Parameter #{} has expression: {}",i,parameterExpression);
  }
  return new Expression(){
    @SuppressWarnings("unchecked") public <T>T evaluate(    Exchange exchange,    Class<T> type){
      Object[] answer=new Object[size];
      Object body=exchange.getIn().getBody();
      boolean multiParameterArray=false;
      if (exchange.getIn().getHeader(Exchange.BEAN_MULTI_PARAMETER_ARRAY) != null) {
        multiParameterArray=exchange.getIn().getHeader(Exchange.BEAN_MULTI_PARAMETER_ARRAY,Boolean.class);
      }
      String methodName=exchange.getIn().getHeader(Exchange.BEAN_METHOD_NAME,"",String.class);
      String methodParameters=ObjectHelper.between(methodName,"(",")");
      Iterator<?> it=null;
      if (methodParameters != null) {
        String[] parameters=StringQuoteHelper.splitSafeQuote(methodParameters,',',true);
        it=ObjectHelper.createIterator(parameters,",",true);
      }
      exchange.getIn().removeHeader(Exchange.BEAN_MULTI_PARAMETER_ARRAY);
      exchange.getIn().removeHeader(Exchange.BEAN_METHOD_NAME);
      for (int i=0; i < size; i++) {
        Object parameterValue=it != null && it.hasNext() ? it.next() : null;
        Class<?> parameterType=parameters.get(i).getType();
        Object value=null;
        if (multiParameterArray) {
          value=((Object[])body)[i];
        }
 else {
          if (parameterValue != null && !parameterValue.equals("*")) {
            value=evaluateParameterValue(exchange,i,parameterValue,parameterType);
          }
          Expression expression=expressions[i];
          if (value == null && expression != null) {
            value=evaluateParameterBinding(exchange,expression,i,parameterType);
          }
        }
        if (value != Void.TYPE) {
          answer[i]=value;
        }
      }
      return (T)answer;
    }
    /** 
 * Evaluate using parameter values where the values can be provided in the method name syntax.
 * <p/>
 * This methods returns accordingly:
 * <ul>
 * <li><tt>null</tt> - if not a parameter value</li>
 * <li><tt>Void.TYPE</tt> - if an explicit null, forcing Camel to pass in <tt>null</tt> for that given parameter</li>
 * <li>a non <tt>null</tt> value - if the parameter was a parameter value, and to be used</li>
 * </ul>
 * @since 2.9
 */
    private Object evaluateParameterValue(    Exchange exchange,    int index,    Object parameterValue,    Class<?> parameterType){
      Object answer=null;
      String exp=exchange.getContext().getTypeConverter().convertTo(String.class,exchange,parameterValue);
      if (exp != null) {
        boolean valid=BeanHelper.isValidParameterValue(exp);
        if (!valid) {
          Boolean isClass=BeanHelper.isAssignableToExpectedType(exchange.getContext().getClassResolver(),exp,parameterType);
          if (isClass != null) {
            return null;
          }
        }
        Expression expression=null;
        try {
          expression=exchange.getContext().resolveLanguage("simple").createExpression(exp);
          parameterValue=expression.evaluate(exchange,Object.class);
        }
 catch (        Exception e) {
          throw new ExpressionEvaluationException(expression,"Cannot create/evaluate simple expression: " + exp + " to be bound to parameter at index: "+ index+ " on method: "+ getMethod(),exchange,e);
        }
        if (parameterValue != null) {
          if ("null".equals(parameterValue)) {
            return Void.TYPE;
          }
          exp=exchange.getContext().getTypeConverter().convertTo(String.class,parameterValue);
          if (!valid) {
            valid=parameterValue instanceof String || BeanHelper.isValidParameterValue(exp);
          }
          if (valid) {
            if (parameterValue instanceof String) {
              parameterValue=StringHelper.removeLeadingAndEndingQuotes((String)parameterValue);
            }
            try {
              answer=exchange.getContext().getTypeConverter().mandatoryConvertTo(parameterType,parameterValue);
              if (LOG.isTraceEnabled()) {
                LOG.trace("Parameter #{} evaluated as: {} type: ",new Object[]{index,answer,ObjectHelper.type(answer)});
              }
            }
 catch (            NoTypeConversionAvailableException e) {
              throw ObjectHelper.wrapCamelExecutionException(exchange,e);
            }
          }
        }
      }
      return answer;
    }
    /** 
 * Evaluate using classic parameter binding using the pre compute expression
 */
    private Object evaluateParameterBinding(    Exchange exchange,    Expression expression,    int index,    Class<?> parameterType){
      Object answer=null;
      Object result=expression.evaluate(exchange,Object.class);
      if (result != null) {
        try {
          answer=exchange.getContext().getTypeConverter().mandatoryConvertTo(parameterType,result);
          if (LOG.isTraceEnabled()) {
            LOG.trace("Parameter #{} evaluated as: {} type: ",new Object[]{index,answer,ObjectHelper.type(answer)});
          }
        }
 catch (        NoTypeConversionAvailableException e) {
          throw ObjectHelper.wrapCamelExecutionException(exchange,e);
        }
      }
 else {
        LOG.trace("Parameter #{} evaluated as null",index);
      }
      return answer;
    }
    @Override public String toString(){
      return "ParametersExpression: " + Arrays.asList(expressions);
    }
  }
;
}
