{
  final int size=parameters.size();
  LOG.trace("Creating parameters expression for {} parameters",size);
  final Expression[] expressions=new Expression[size];
  for (int i=0; i < size; i++) {
    Expression parameterExpression=parameters.get(i).getExpression();
    expressions[i]=parameterExpression;
    LOG.trace("Parameter #{} has expression: {}",i,parameterExpression);
  }
  return new Expression(){
    @SuppressWarnings("unchecked") public <T>T evaluate(    Exchange exchange,    Class<T> type){
      Object[] answer=new Object[size];
      Object body=exchange.getIn().getBody();
      boolean multiParameterArray=false;
      if (exchange.getIn().getHeader(Exchange.BEAN_MULTI_PARAMETER_ARRAY) != null) {
        multiParameterArray=exchange.getIn().getHeader(Exchange.BEAN_MULTI_PARAMETER_ARRAY,Boolean.class);
      }
      for (int i=0; i < size; i++) {
        Object value=null;
        if (multiParameterArray) {
          value=((Object[])body)[i];
        }
 else {
          Expression expression=expressions[i];
          if (expression != null) {
            Object result=expression.evaluate(exchange,Object.class);
            if (result != null) {
              try {
                value=exchange.getContext().getTypeConverter().mandatoryConvertTo(parameters.get(i).getType(),result);
                if (LOG.isTraceEnabled()) {
                  LOG.trace("Parameter #{} evaluated as: {} type: ",new Object[]{i,value,ObjectHelper.type(value)});
                }
              }
 catch (              NoTypeConversionAvailableException e) {
                throw ObjectHelper.wrapCamelExecutionException(exchange,e);
              }
            }
 else {
              LOG.trace("Parameter #{} evaluated as null",i);
            }
          }
        }
        answer[i]=value;
      }
      return (T)answer;
    }
    @Override public String toString(){
      return "ParametersExpression: " + Arrays.asList(expressions);
    }
  }
;
}
