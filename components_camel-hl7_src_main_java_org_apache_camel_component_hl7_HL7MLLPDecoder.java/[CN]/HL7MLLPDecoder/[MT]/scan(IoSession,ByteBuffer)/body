{
  DecoderState state=decoderState(session);
  in.position(state.current);
  LOG.debug("Start scanning buffer at position " + in.position());
  while (in.hasRemaining()) {
    byte b=in.get();
    if (b == config.getStartByte()) {
      if (state.posStart > 0 || state.waitingForEndByte2) {
        LOG.warn("Ignoring message start at position " + in.position() + " before previous message has ended.");
      }
 else {
        state.posStart=in.position();
        state.waitingForEndByte2=false;
        if (LOG.isDebugEnabled()) {
          LOG.debug("Message starts at position " + state.posStart);
        }
      }
    }
    if (b == config.getEndByte1()) {
      if (!state.waitingForEndByte2 && state.posStart > 0) {
        state.waitingForEndByte2=true;
      }
 else {
        LOG.warn("Ignoring unexpected 1st end byte " + b + ". Expected 2nd endpoint  "+ config.getEndByte2());
      }
    }
    if (b == config.getEndByte2() && state.waitingForEndByte2) {
      state.posEnd=in.position() - 2;
      state.waitingForEndByte2=false;
      if (LOG.isDebugEnabled()) {
        LOG.debug("Message ends at position " + state.posEnd);
      }
      break;
    }
  }
  state.current=in.position();
  in.rewind();
  return state.posEnd > 0;
}
