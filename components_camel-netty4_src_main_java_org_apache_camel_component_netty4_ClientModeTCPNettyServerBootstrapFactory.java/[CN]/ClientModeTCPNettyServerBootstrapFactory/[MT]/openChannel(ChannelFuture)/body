{
  if (LOG.isTraceEnabled()) {
    LOG.trace("Waiting for operation to complete {} for {} millis",channelFuture,configuration.getConnectTimeout());
  }
  final CountDownLatch channelLatch=new CountDownLatch(1);
  channelFuture.addListener(new ChannelFutureListener(){
    @Override public void operationComplete(    ChannelFuture cf) throws Exception {
      channelLatch.countDown();
    }
  }
);
  try {
    channelLatch.await(configuration.getConnectTimeout(),TimeUnit.MILLISECONDS);
  }
 catch (  InterruptedException ex) {
    throw new CamelException("Interrupted while waiting for " + "connection to " + configuration.getAddress());
  }
  if (!channelFuture.isDone() || !channelFuture.isSuccess()) {
    if (configuration.isReconnect()) {
      final EventLoop loop=channelFuture.channel().eventLoop();
      loop.schedule(new Runnable(){
        @Override public void run(){
          try {
            LOG.trace("Re-connecting to {} if needed",configuration.getAddress());
            doReconnectIfNeeded();
          }
 catch (          Exception e) {
            LOG.warn("Error during re-connect to " + configuration.getAddress() + ". Will attempt again in "+ configuration.getReconnectInterval()+ " millis. This exception is ignored.",e);
          }
        }
      }
,configuration.getReconnectInterval(),TimeUnit.MILLISECONDS);
    }
 else {
      ConnectException cause=new ConnectException("Cannot connect to " + configuration.getAddress());
      if (channelFuture.cause() != null) {
        cause.initCause(channelFuture.cause());
      }
      throw cause;
    }
  }
  Channel answer=channelFuture.channel();
  if (LOG.isDebugEnabled()) {
    LOG.debug("Creating connector to address: {}",configuration.getAddress());
  }
  return answer;
}
