{
  if (LOG.isTraceEnabled()) {
    LOG.trace("Polling file: " + file);
  }
  if (!file.exists()) {
    return 0;
  }
  if (!isValidFile(file)) {
    return 0;
  }
  if (!endpoint.isNoop()) {
    if (filesBeingProcessed.contains(file)) {
      return 1;
    }
    filesBeingProcessed.put(file,file);
  }
  final FileProcessStrategy processStrategy=endpoint.getFileStrategy();
  final FileExchange exchange=endpoint.createExchange(file);
  endpoint.configureMessage(file,exchange.getIn());
  try {
    if (exclusiveReadLock) {
      acquireExclusiveReadLock(file);
    }
    if (LOG.isDebugEnabled()) {
      LOG.debug("About to process file: " + file + " using exchange: "+ exchange);
    }
    if (processStrategy.begin(endpoint,exchange,file)) {
      getAsyncProcessor().process(exchange,new AsyncCallback(){
        public void done(        boolean sync){
          boolean failed=exchange.isFailed();
          boolean handled=DeadLetterChannel.isFailureHandled(exchange);
          if (LOG.isDebugEnabled()) {
            LOG.debug("Done processing file: " + file + ". Status is: "+ (failed ? "failed: " + failed + ", handled by failure processor: "+ handled : "processed OK"));
          }
          if (!failed || handled) {
            processStrategyCommit(processStrategy,exchange,file,handled);
          }
 else           if (failed && !handled) {
            handleException(exchange.getException());
          }
          filesBeingProcessed.remove(file);
        }
      }
);
    }
 else {
      if (LOG.isDebugEnabled()) {
        LOG.debug(endpoint + " can not process file: " + file);
      }
    }
  }
 catch (  Throwable e) {
    handleException(e);
  }
  return 1;
}
