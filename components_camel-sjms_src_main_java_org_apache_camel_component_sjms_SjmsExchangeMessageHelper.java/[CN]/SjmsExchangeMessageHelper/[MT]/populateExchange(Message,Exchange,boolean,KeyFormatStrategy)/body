{
  try {
    SjmsExchangeMessageHelper.setJmsMessageHeaders(message,exchange,out,keyFormatStrategy);
    if (message != null) {
      DefaultMessage bodyMessage=null;
      if (out) {
        bodyMessage=(DefaultMessage)exchange.getOut();
      }
 else {
        bodyMessage=(DefaultMessage)exchange.getIn();
      }
switch (JmsMessageHelper.discoverJmsMessageType(message)) {
case Bytes:
        BytesMessage bytesMessage=(BytesMessage)message;
      if (bytesMessage.getBodyLength() > Integer.MAX_VALUE) {
        LOGGER.warn("Length of BytesMessage is too long: {}",bytesMessage.getBodyLength());
        return null;
      }
    byte[] result=new byte[(int)bytesMessage.getBodyLength()];
  bytesMessage.readBytes(result);
bodyMessage.setHeader(JMS_MESSAGE_TYPE,JmsMessageType.Bytes);
bodyMessage.setBody(result);
break;
case Map:
Map<String,Object> body=new HashMap<String,Object>();
MapMessage mapMessage=(MapMessage)message;
Enumeration<String> names=mapMessage.getMapNames();
while (names.hasMoreElements()) {
String key=names.nextElement();
Object value=mapMessage.getObject(key);
body.put(key,value);
}
bodyMessage.setHeader(JMS_MESSAGE_TYPE,JmsMessageType.Map);
bodyMessage.setBody(body);
break;
case Object:
ObjectMessage objMsg=(ObjectMessage)message;
bodyMessage.setHeader(JMS_MESSAGE_TYPE,JmsMessageType.Object);
bodyMessage.setBody(objMsg.getObject());
break;
case Text:
TextMessage textMsg=(TextMessage)message;
bodyMessage.setHeader(JMS_MESSAGE_TYPE,JmsMessageType.Text);
bodyMessage.setBody(textMsg.getText());
break;
case Stream:
StreamMessage streamMessage=(StreamMessage)message;
ByteArrayOutputStream baos=new ByteArrayOutputStream();
int next=streamMessage.readByte();
while (next > -1) {
baos.write(next);
next=streamMessage.readByte();
}
baos.flush();
bodyMessage.setHeader(JMS_MESSAGE_TYPE,JmsMessageType.Bytes);
bodyMessage.setBody(baos.toByteArray());
break;
case Message:
default :
bodyMessage.setBody(message);
break;
}
}
}
 catch (Exception e) {
exchange.setException(e);
}
return exchange;
}
