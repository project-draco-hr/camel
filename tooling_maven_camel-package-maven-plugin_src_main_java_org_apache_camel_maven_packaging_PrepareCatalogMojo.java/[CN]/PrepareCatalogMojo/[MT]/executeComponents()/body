{
  getLog().info("Copying all Camel component json descriptors");
  Set<File> jsonFiles=new TreeSet<File>();
  Set<File> duplicateJsonFiles=new TreeSet<File>();
  Set<File> componentFiles=new TreeSet<File>();
  Set<File> missingComponents=new TreeSet<File>();
  Set<File> missingLabels=new TreeSet<File>();
  Set<File> missingUriPaths=new TreeSet<File>();
  Set<File> missingJavaDoc=new TreeSet<File>();
  Map<String,Set<String>> usedLabels=new TreeMap<String,Set<String>>();
  if (componentsDir != null && componentsDir.isDirectory()) {
    File[] components=componentsDir.listFiles();
    if (components != null) {
      for (      File dir : components) {
        if (dir.isDirectory() && !"target".equals(dir.getName())) {
          File target=new File(dir,"target/classes");
          int before=componentFiles.size();
          int before2=jsonFiles.size();
          findComponentFilesRecursive(target,jsonFiles,componentFiles,new CamelComponentsFileFilter());
          int after=componentFiles.size();
          int after2=jsonFiles.size();
          if (before != after && before2 == after2) {
            missingComponents.add(dir);
          }
        }
      }
    }
  }
  if (coreDir != null && coreDir.isDirectory()) {
    File target=new File(coreDir,"target/classes");
    int before=componentFiles.size();
    int before2=jsonFiles.size();
    findComponentFilesRecursive(target,jsonFiles,componentFiles,new CamelComponentsFileFilter());
    int after=componentFiles.size();
    int after2=jsonFiles.size();
    if (before != after && before2 == after2) {
      missingComponents.add(coreDir);
    }
  }
  getLog().info("Found " + componentFiles.size() + " component.properties files");
  getLog().info("Found " + jsonFiles.size() + " component json files");
  componentsOutDir.mkdirs();
  for (  File file : jsonFiles) {
    File to=new File(componentsOutDir,file.getName());
    if (to.exists()) {
      duplicateJsonFiles.add(to);
      getLog().warn("Duplicate component name detected: " + to);
    }
    try {
      copyFile(file,to);
    }
 catch (    IOException e) {
      throw new MojoFailureException("Cannot copy file from " + file + " -> "+ to,e);
    }
    try {
      String text=loadText(new FileInputStream(file));
      if (text.contains("\"label\": \"\"")) {
        missingLabels.add(file);
      }
 else {
        String name=asComponentName(file);
        Matcher matcher=LABEL_PATTERN.matcher(text);
        if (matcher.find()) {
          String label=matcher.group(1);
          String[] labels=label.split(",");
          for (          String s : labels) {
            Set<String> components=usedLabels.get(s);
            if (components == null) {
              components=new TreeSet<String>();
              usedLabels.put(s,components);
            }
            components.add(name);
          }
        }
      }
      if (!text.contains("\"kind\": \"path\"")) {
        missingUriPaths.add(file);
      }
      List<Map<String,String>> rows=JSonSchemaHelper.parseJsonSchema("properties",text,true);
      for (      Map<String,String> row : rows) {
        String doc=row.get("description");
        if (doc == null || doc.isEmpty()) {
          missingJavaDoc.add(file);
          break;
        }
      }
    }
 catch (    IOException e) {
    }
  }
  File all=new File(componentsOutDir,"../components.properties");
  try {
    FileOutputStream fos=new FileOutputStream(all,false);
    String[] names=componentsOutDir.list();
    List<String> components=new ArrayList<String>();
    for (    String name : names) {
      if (name.endsWith(".json")) {
        String componentName=name.substring(0,name.length() - 5);
        components.add(componentName);
      }
    }
    Collections.sort(components);
    for (    String name : components) {
      fos.write(name.getBytes());
      fos.write("\n".getBytes());
    }
    fos.close();
  }
 catch (  IOException e) {
    throw new MojoFailureException("Error writing to file " + all);
  }
  printComponentsReport(jsonFiles,duplicateJsonFiles,missingComponents,missingJavaDoc,missingUriPaths,missingLabels,usedLabels);
}
