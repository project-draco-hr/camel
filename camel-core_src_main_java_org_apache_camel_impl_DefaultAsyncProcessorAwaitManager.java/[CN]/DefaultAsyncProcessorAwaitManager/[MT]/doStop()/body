{
  Collection<AwaitThread> threads=browse();
  int count=threads.size();
  if (count > 0) {
    LOG.warn("Shutting down while there are still " + count + " inflight threads currently blocked.");
    StringBuilder sb=new StringBuilder();
    for (    AwaitThread entry : threads) {
      sb.append("\tBlocked thread: ").append(entry.getBlockedThread().getName()).append(", exchangeId=").append(entry.getExchange().getExchangeId()).append(", duration=").append(entry.getWaitDuration()).append(" msec.");
    }
    if (isInterruptThreadsWhileStopping()) {
      LOG.warn("The following threads are blocked and will be interrupted so the threads are released:\n" + sb.toString());
      for (      AwaitThread entry : threads) {
        try {
          interrupt(entry.getExchange());
        }
 catch (        Throwable e) {
          LOG.warn("Error while interrupting thread: " + entry.getBlockedThread().getName() + ". This exception is ignored.",e);
        }
      }
    }
 else {
      LOG.warn("The following threads are blocked, and may reside in the JVM:\n" + sb.toString());
    }
  }
 else {
    LOG.debug("Shutting down with no inflight threads.");
  }
  inflight.clear();
}
