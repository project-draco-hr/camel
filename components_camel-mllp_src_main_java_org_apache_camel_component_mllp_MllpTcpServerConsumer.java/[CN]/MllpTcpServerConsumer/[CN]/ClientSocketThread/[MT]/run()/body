{
  while (!isInterrupted() && null != clientSocket && clientSocket.isConnected() && !clientSocket.isClosed()) {
    byte[] hl7MessageBytes=null;
    log.debug("Reading data ....");
    try {
      if (null != initialByte && START_OF_BLOCK == initialByte) {
        hl7MessageBytes=MllpUtil.closeFrame(clientSocket);
      }
 else {
        try {
          if (!MllpUtil.openFrame(clientSocket)) {
            continue;
          }
        }
 catch (        SocketTimeoutException timeoutEx) {
          continue;
        }
        hl7MessageBytes=MllpUtil.closeFrame(clientSocket);
      }
    }
 catch (    MllpException mllpEx) {
      Exchange exchange=endpoint.createExchange(ExchangePattern.InOut);
      exchange.setException(mllpEx);
      return;
    }
 finally {
      initialByte=null;
    }
    if (null == hl7MessageBytes) {
      continue;
    }
    log.debug("Populating the exchange with received message");
    Exchange exchange=endpoint.createExchange(ExchangePattern.InOut);
    Message message=exchange.getIn();
    message.setBody(hl7MessageBytes,byte[].class);
    message.setHeader(MLLP_LOCAL_ADDRESS,clientSocket.getLocalAddress().toString());
    message.setHeader(MLLP_REMOTE_ADDRESS,clientSocket.getRemoteSocketAddress());
    populateHl7DataHeaders(exchange,message,hl7MessageBytes);
    log.debug("Calling processor");
    try {
      getProcessor().process(exchange);
      if (exchange.getProperty(MLLP_RESET_CONNECTION_BEFORE_SEND,boolean.class)) {
        MllpUtil.resetConnection(clientSocket);
        return;
      }
 else       if (exchange.getProperty(MLLP_CLOSE_CONNECTION_BEFORE_SEND,boolean.class)) {
        MllpUtil.closeConnection(clientSocket);
      }
      byte[] acknowledgementMessageBytes=exchange.getProperty(MLLP_ACKNOWLEDGEMENT,byte[].class);
      String acknowledgementMessageType=null;
      if (null == acknowledgementMessageBytes) {
        if (!endpoint.autoAck) {
          exchange.setException(new MllpInvalidAcknowledgementException("Automatic Acknowledgement is disabled and the " + MLLP_ACKNOWLEDGEMENT + " exchange property is null or cannot be converted to byte[]"));
          return;
        }
        String acknowledgmentTypeProperty=exchange.getProperty(MLLP_ACKNOWLEDGEMENT_TYPE,String.class);
        try {
          if (null == acknowledgmentTypeProperty) {
            if (null == exchange.getException()) {
              acknowledgementMessageType="AA";
              acknowledgementMessageBytes=acknowledgementGenerator.generateApplicationAcceptAcknowledgementMessage(hl7MessageBytes);
            }
 else {
              acknowledgementMessageType="AE";
              acknowledgementMessageBytes=acknowledgementGenerator.generateApplicationErrorAcknowledgementMessage(hl7MessageBytes);
            }
          }
 else {
switch (acknowledgmentTypeProperty) {
case "AA":
              acknowledgementMessageType="AA";
            acknowledgementMessageBytes=acknowledgementGenerator.generateApplicationAcceptAcknowledgementMessage(hl7MessageBytes);
          break;
case "AE":
        acknowledgementMessageType="AE";
      acknowledgementMessageBytes=acknowledgementGenerator.generateApplicationErrorAcknowledgementMessage(hl7MessageBytes);
    break;
case "AR":
  acknowledgementMessageType="AR";
acknowledgementMessageBytes=acknowledgementGenerator.generateApplicationRejectAcknowledgementMessage(hl7MessageBytes);
break;
default :
exchange.setException(new Hl7AcknowledgementGenerationException("Unsupported acknowledgment type: " + acknowledgmentTypeProperty));
return;
}
}
}
 catch (Hl7AcknowledgementGenerationException ackGenerationException) {
exchange.setException(ackGenerationException);
}
}
 else {
final byte bM=77;
final byte bS=83;
final byte bA=65;
final byte bE=69;
final byte bR=82;
final byte fieldSeparator=hl7MessageBytes[3];
for (int i=0; i < hl7MessageBytes.length; ++i) {
if (SEGMENT_DELIMITER == i) {
if (i + 7 < hl7MessageBytes.length && bM == hl7MessageBytes[i + 1] && bS == hl7MessageBytes[i + 2] && bA == hl7MessageBytes[i + 3] && fieldSeparator == hl7MessageBytes[i + 4]) {
if (fieldSeparator != hl7MessageBytes[i + 7]) {
log.warn("MSA-1 is longer than 2-bytes - ignoring trailing bytes");
}
byte[] acknowledgmentTypeBytes=new byte[2];
acknowledgmentTypeBytes[0]=hl7MessageBytes[i + 5];
acknowledgmentTypeBytes[1]=hl7MessageBytes[i + 6];
acknowledgementMessageType=IOConverter.toString(acknowledgmentTypeBytes,exchange);
if (bA != acknowledgmentTypeBytes[0]) {
switch (acknowledgementMessageBytes[1]) {
case bA:
case bR:
case bE:
break;
default :
log.warn("Invalid acknowledgement type [" + acknowledgementMessageType + "] found in message - should be AA, AE or AR");
}
}
String acknowledgementTypeProperty=exchange.getProperty(MLLP_ACKNOWLEDGEMENT_TYPE,String.class);
if (null != acknowledgementTypeProperty && !acknowledgementTypeProperty.equals(acknowledgementMessageType)) {
log.warn("Acknowledgement type found in message [" + acknowledgementMessageType + "] does not match "+ MLLP_ACKNOWLEDGEMENT_TYPE+ " exchange property value ["+ acknowledgementTypeProperty+ "] - using value found in message");
}
}
}
}
}
log.debug("Writing Acknowledgement");
MllpUtil.writeFramedPayload(clientSocket,acknowledgementMessageBytes);
exchange.getIn().setHeader(MLLP_ACKNOWLEDGEMENT,acknowledgementMessageBytes);
exchange.getIn().setHeader(MLLP_ACKNOWLEDGEMENT_TYPE,acknowledgementMessageType);
if (exchange.getProperty(MLLP_RESET_CONNECTION_AFTER_SEND,boolean.class)) {
MllpUtil.resetConnection(clientSocket);
return;
}
 else if (exchange.getProperty(MLLP_CLOSE_CONNECTION_AFTER_SEND,boolean.class)) {
MllpUtil.closeConnection(clientSocket);
}
}
 catch (Exception e) {
exchange.setException(e);
}
}
log.info("ClientSocketThread exiting");
}
