{
  if (encryptedStream == null) {
    return null;
  }
  InputStream in=PGPUtil.getDecoderStream(encryptedStream);
  PGPObjectFactory pgpFactory=new PGPObjectFactory(in);
  Object firstObject=pgpFactory.nextObject();
  PGPEncryptedDataList enc;
  if (firstObject instanceof PGPEncryptedDataList) {
    enc=(PGPEncryptedDataList)firstObject;
  }
 else {
    Object secondObject=pgpFactory.nextObject();
    if (secondObject instanceof PGPEncryptedDataList) {
      enc=(PGPEncryptedDataList)secondObject;
    }
 else {
      enc=null;
    }
  }
  if (enc == null) {
    throw getFormatException();
  }
  PGPPublicKeyEncryptedData pbe=null;
  PGPPrivateKey key=null;
  for (int i=0; i < enc.size() && key == null; i++) {
    Object encryptedData=enc.get(i);
    if (!(encryptedData instanceof PGPPublicKeyEncryptedData)) {
      throw getFormatException();
    }
    pbe=(PGPPublicKeyEncryptedData)encryptedData;
    key=secretKeyAccessor.getPrivateKey(exchange,pbe.getKeyID());
    if (key != null) {
      break;
    }
  }
  if (key == null) {
    throw new PGPException("Message is encrypted with a key which could not be found in the Secret Key Ring.");
  }
  InputStream encData=pbe.getDataStream(new JcePublicKeyDataDecryptorFactoryBuilder().setProvider(getProvider()).build(key));
  pgpFactory=new PGPObjectFactory(encData);
  Object compObj=pgpFactory.nextObject();
  if (!(compObj instanceof PGPCompressedData)) {
    throw getFormatException();
  }
  PGPCompressedData comData=(PGPCompressedData)compObj;
  pgpFactory=new PGPObjectFactory(comData.getDataStream());
  Object object=pgpFactory.nextObject();
  PGPOnePassSignature signature;
  if (object instanceof PGPOnePassSignatureList) {
    signature=getSignature(exchange,(PGPOnePassSignatureList)object);
    object=pgpFactory.nextObject();
  }
 else {
    signature=null;
  }
  PGPLiteralData ld;
  if (object instanceof PGPLiteralData) {
    ld=(PGPLiteralData)object;
  }
 else {
    throw getFormatException();
  }
  InputStream litData=ld.getInputStream();
  CachedOutputStream cos;
  ByteArrayOutputStream bos;
  OutputStream os;
  if (exchange.getContext().getStreamCachingStrategy().isEnabled()) {
    cos=new CachedOutputStream(exchange);
    bos=null;
    os=cos;
  }
 else {
    cos=null;
    bos=new ByteArrayOutputStream();
    os=bos;
  }
  try {
    byte[] buffer=new byte[BUFFER_SIZE];
    int bytesRead;
    while ((bytesRead=litData.read(buffer)) != -1) {
      os.write(buffer,0,bytesRead);
      if (signature != null) {
        signature.update(buffer,0,bytesRead);
      }
      os.flush();
    }
  }
  finally {
    IOHelper.close(os,litData,encData,in);
  }
  if (signature != null) {
    PGPSignatureList sigList=(PGPSignatureList)pgpFactory.nextObject();
    if (!signature.verify(getSignatureWithKeyId(signature.getKeyID(),sigList))) {
      throw new SignatureException("Cannot verify PGP signature");
    }
  }
  if (cos != null) {
    return cos.newStreamCache();
  }
 else {
    return bos.toByteArray();
  }
}
