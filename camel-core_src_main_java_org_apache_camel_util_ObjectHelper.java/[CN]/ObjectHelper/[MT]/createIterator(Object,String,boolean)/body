{
  if (value instanceof Message) {
    value=((Message)value).getBody();
  }
  if (value == null) {
    return Collections.emptyList().iterator();
  }
 else   if (value instanceof Iterator) {
    return (Iterator<Object>)value;
  }
 else   if (value instanceof Iterable) {
    return ((Iterable<Object>)value).iterator();
  }
 else   if (value.getClass().isArray()) {
    if (isPrimitiveArrayType(value.getClass())) {
      final Object array=value;
      return new Iterator<Object>(){
        int idx=-1;
        public boolean hasNext(){
          return (idx + 1) < length();
        }
        public Object next(){
          idx++;
          return current(idx);
        }
        public void remove(){
          throw new UnsupportedOperationException();
        }
        private int length(){
          int answer=0;
          if (array instanceof byte[]) {
            answer=((byte[])array).length;
          }
 else           if (array instanceof short[]) {
            answer=((short[])array).length;
          }
 else           if (array instanceof int[]) {
            answer=((int[])array).length;
          }
 else           if (array instanceof long[]) {
            answer=((long[])array).length;
          }
 else           if (array instanceof float[]) {
            answer=((float[])array).length;
          }
 else           if (array instanceof double[]) {
            answer=((double[])array).length;
          }
 else           if (array instanceof char[]) {
            answer=((char[])array).length;
          }
 else           if (array instanceof boolean[]) {
            answer=((boolean[])array).length;
          }
 else {
            throw new IllegalStateException("Unexpected type for " + array);
          }
          return answer;
        }
        private Object current(        int index){
          Object answer=0;
          if (array instanceof byte[]) {
            answer=Byte.valueOf(((byte[])array)[index]);
          }
 else           if (array instanceof short[]) {
            answer=Short.valueOf(((short[])array)[index]);
          }
 else           if (array instanceof int[]) {
            answer=Integer.valueOf(((int[])array)[index]);
          }
 else           if (array instanceof long[]) {
            answer=Long.valueOf(((long[])array)[index]);
          }
 else           if (array instanceof float[]) {
            answer=Float.valueOf(((float[])array)[index]);
          }
 else           if (array instanceof double[]) {
            answer=Double.valueOf(((double[])array)[index]);
          }
 else           if (array instanceof char[]) {
            answer=Character.valueOf(((char[])array)[index]);
          }
 else           if (array instanceof boolean[]) {
            answer=Boolean.valueOf(((boolean[])array)[index]);
          }
 else {
            throw new IllegalStateException("Unexpected type for " + array);
          }
          return answer;
        }
      }
;
    }
 else {
      List<Object> list=Arrays.asList((Object[])value);
      return list.iterator();
    }
  }
 else   if (value instanceof NodeList) {
    final NodeList nodeList=(NodeList)value;
    return new Iterator<Object>(){
      int idx=-1;
      public boolean hasNext(){
        return (idx + 1) < nodeList.getLength();
      }
      public Object next(){
        idx++;
        return nodeList.item(idx);
      }
      public void remove(){
        throw new UnsupportedOperationException();
      }
    }
;
  }
 else   if (value instanceof String) {
    final String s=(String)value;
    if (delimiter != null && s.contains(delimiter)) {
      Scanner scanner=new Scanner((String)value);
      if (DEFAULT_DELIMITER.equals(delimiter)) {
        delimiter=",(?!(?:[^\\(,]|[^\\)],[^\\)])+\\))";
      }
      scanner.useDelimiter(delimiter);
      return CastUtils.cast(scanner);
    }
 else {
      return new Iterator<Object>(){
        int idx=-1;
        public boolean hasNext(){
          return idx + 1 == 0 && (allowEmptyValues || ObjectHelper.isNotEmpty(s));
        }
        public Object next(){
          idx++;
          return s;
        }
        public void remove(){
          throw new UnsupportedOperationException();
        }
      }
;
    }
  }
 else {
    return Collections.singletonList(value).iterator();
  }
}
