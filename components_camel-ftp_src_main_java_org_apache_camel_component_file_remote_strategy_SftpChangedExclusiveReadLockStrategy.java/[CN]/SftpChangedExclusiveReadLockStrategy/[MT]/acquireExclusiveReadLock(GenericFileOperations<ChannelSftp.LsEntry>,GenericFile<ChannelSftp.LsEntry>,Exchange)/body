{
  boolean exclusive=false;
  LOG.trace("Waiting for exclusive read lock to file: " + file);
  long lastModified=Long.MIN_VALUE;
  long length=Long.MIN_VALUE;
  StopWatch watch=new StopWatch();
  long startTime=(new Date()).getTime();
  while (!exclusive) {
    if (timeout > 0) {
      long delta=watch.taken();
      if (delta > timeout) {
        CamelLogger.log(LOG,readLockLoggingLevel,"Cannot acquire read lock within " + timeout + " millis. Will skip the file: "+ file);
        return false;
      }
    }
    long newLastModified=0;
    long newLength=0;
    List<ChannelSftp.LsEntry> files;
    if (fastExistsCheck) {
      LOG.trace("Using fast exists to update file information for {}",file);
      files=operations.listFiles(file.getAbsoluteFilePath());
    }
 else {
      LOG.trace("Using full directory listing to update file information for {}. Consider enabling fastExistsCheck option.",file);
      files=operations.listFiles(file.getParent());
    }
    LOG.trace("List files {} found {} files",file.getAbsoluteFilePath(),files.size());
    for (    ChannelSftp.LsEntry f : files) {
      if (f.getFilename().equals(file.getFileNameOnly())) {
        newLastModified=f.getAttrs().getMTime();
        newLength=f.getAttrs().getSize();
      }
    }
    LOG.trace("Previous last modified: " + lastModified + ", new last modified: "+ newLastModified);
    LOG.trace("Previous length: " + length + ", new length: "+ newLength);
    long newOlderThan=startTime + watch.taken() - minAge;
    LOG.trace("New older than threshold: {}",newOlderThan);
    if (newLength >= minLength && ((minAge == 0 && newLastModified == lastModified && newLength == length) || (minAge != 0 && newLastModified < newOlderThan))) {
      LOG.trace("Read lock acquired.");
      exclusive=true;
    }
 else {
      lastModified=newLastModified;
      length=newLength;
      boolean interrupted=sleep();
      if (interrupted) {
        return false;
      }
    }
  }
  return exclusive;
}
