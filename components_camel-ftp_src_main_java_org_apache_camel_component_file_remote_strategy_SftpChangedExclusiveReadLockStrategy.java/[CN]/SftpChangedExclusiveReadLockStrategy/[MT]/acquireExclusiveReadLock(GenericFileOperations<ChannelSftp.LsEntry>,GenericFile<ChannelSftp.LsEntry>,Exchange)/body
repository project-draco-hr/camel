{
  boolean exclusive=false;
  LOG.trace("Waiting for exclusive read lock to file: " + file);
  long lastModified=Long.MIN_VALUE;
  long length=Long.MIN_VALUE;
  StopWatch watch=new StopWatch();
  while (!exclusive) {
    if (timeout > 0) {
      long delta=watch.taken();
      if (delta > timeout) {
        LOG.warn("Cannot acquire read lock within " + timeout + " millis. Will skip the file: "+ file);
        return false;
      }
    }
    long newLastModified=0;
    long newLength=0;
    List<ChannelSftp.LsEntry> files;
    if (fastExistsCheck) {
      LOG.trace("Using fast exists to update file information for {}",file);
      files=operations.listFiles(file.getAbsoluteFilePath());
    }
 else {
      LOG.trace("Using full directory listing to update file information for {}. Consider enabling fastExistsCheck option.",file);
      files=operations.listFiles(file.getParent());
    }
    LOG.trace("List files {} found {} files",file.getAbsoluteFilePath(),files.size());
    for (    ChannelSftp.LsEntry f : files) {
      if (f.getFilename().equals(file.getFileName())) {
        newLastModified=f.getAttrs().getMTime();
        newLength=f.getAttrs().getSize();
      }
    }
    LOG.trace("Previous last modified: " + lastModified + ", new last modified: "+ newLastModified);
    LOG.trace("Previous length: " + length + ", new length: "+ newLength);
    if (length >= minLength && (newLastModified == lastModified && newLength == length)) {
      LOG.trace("Read lock acquired.");
      exclusive=true;
    }
 else {
      lastModified=newLastModified;
      length=newLength;
      boolean interrupted=sleep();
      if (interrupted) {
        return false;
      }
    }
  }
  return exclusive;
}
