{
  if (LOG.isTraceEnabled()) {
    LOG.trace("Finding best suited exception policy for thrown exception " + exception.getClass().getName());
  }
  int targetLevel=getInheritanceLevel(exception.getClass());
  OnExceptionDefinition candidate=null;
  int candidateDiff=Integer.MAX_VALUE;
  Set<Map.Entry<ExceptionPolicyKey,OnExceptionDefinition>> entries=exceptionPolicies.entrySet();
  for (  Map.Entry<ExceptionPolicyKey,OnExceptionDefinition> entry : entries) {
    Class<?> clazz=entry.getKey().getExceptionClass();
    OnExceptionDefinition type=entry.getValue();
    if (filter(type,clazz,exception)) {
      if (!matchesWhen(type,exchange)) {
        if (LOG.isTraceEnabled()) {
          LOG.trace("The type did not match when: " + type);
        }
        continue;
      }
      if (clazz.equals(exception.getClass())) {
        candidate=type;
        candidateDiff=0;
        break;
      }
      int level=getInheritanceLevel(clazz);
      int diff=targetLevel - level;
      if (diff < candidateDiff) {
        candidate=type;
        candidateDiff=diff;
      }
    }
  }
  if (candidate != null) {
    if (!candidates.containsKey(candidateDiff)) {
      if (LOG.isTraceEnabled()) {
        LOG.trace("Adding " + candidate + " as candidate at level "+ candidateDiff);
      }
      candidates.put(candidateDiff,candidate);
    }
 else {
      if (LOG.isTraceEnabled()) {
        LOG.trace("Existing candidate " + candidates.get(candidateDiff) + " takes precedence over "+ candidate+ " at level "+ candidateDiff);
      }
    }
  }
  boolean exactMatch=candidateDiff == 0;
  if (LOG.isTraceEnabled() && exactMatch) {
    LOG.trace("Exact match found for candidate: " + candidate);
  }
  return exactMatch;
}
