{
  if (LOG.isTraceEnabled()) {
    LOG.trace("Finding best suited exception policy for thrown exception " + exception.getClass().getName());
  }
  int targetLevel=getInheritanceLevel(exception.getClass());
  OnExceptionDefinition candidate=null;
  int candidateDiff=Integer.MAX_VALUE;
  Set<Map.Entry<ExceptionPolicyKey,OnExceptionDefinition>> entries=exceptionPolicices.entrySet();
  for (  Map.Entry<ExceptionPolicyKey,OnExceptionDefinition> entry : entries) {
    Class clazz=entry.getKey().getExceptionClass();
    OnExceptionDefinition type=entry.getValue();
    if (filter(type,clazz,exception)) {
      if (!matchesWhen(type,exchange)) {
        if (LOG.isTraceEnabled()) {
          LOG.trace("The type did not match when: " + type);
        }
        continue;
      }
      if (clazz.equals(exception.getClass())) {
        candidate=type;
        break;
      }
      int level=getInheritanceLevel(clazz);
      int diff=targetLevel - level;
      if (diff < candidateDiff) {
        candidate=type;
        candidateDiff=diff;
      }
    }
  }
  if (LOG.isTraceEnabled()) {
    if (candidate != null) {
      LOG.trace("Using " + candidate + " as the exception policy");
    }
 else {
      LOG.trace("No candidate found to be used as exception policy");
    }
  }
  return candidate;
}
